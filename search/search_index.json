{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction River estuaries are transition zones between freshwater and marine ecosystems. They provide essential habitat for both resident and migratory species. Salmon, lamprey, and other species need to access streams and floodplains that are vital for their foraging, spawning, refuge, and rest. For more than 100 years residents of the Oregon coast have created tide gates, levees, and other barriers to help control the tide and protect farm land, roads, building, and other infrastructure. Many of the tide gates are failing and should be replaced with modern designs that meet current fish passage regulations. The Nature Conservancy has developed a decision support system named the Tide Gate Optimization Tool to help landowners and other stakeholders balance the potential gain and costs. The goal is to help users identify \"the best bang for the buck\": given a set of budget levels, which set of barriers will provide the most benefit for each budget? Web Application This document describes a web interface to the Tide Gate Optimization Tool. The web application is written in Python, using Panel to display a GUI where users can enter optimization parameters. The screenshot below shows the the main interface. Geographic Regions The first section in the GUI shows the names of the estuaries in the data set. The user simply clicks on next to the river's name to select the region(s) they are interested in. All the gates in the selected regions are displayed on the map on the left side of the GUI. Budget Levels Potential benefits are often displayed as return on investment (ROI) curves. To produce ROI curves the optimizer needs to be run at several different budget levels. The simplest way to do this is to use the GUI to select a maximum budget level. In the example shown the maximum is set at $5M (short for \"5 million\"). The optimization algorithm will be run 10 times, with budgets varying from $500,000 to $5,000,000 in increments of $500,000. Optimization Goals The last part of the GUI shown in this screenshot lets users specify their priorities (or \"targets\", using the terminology from the optimization algorithm). In this example the user has selected three different goals -- improving habitat for two species of fish and protecting farmland (or other acreage) in the inundation zone. The optimization algorithm will take all of them into account as it selects the optimal set of gates. Outputs When all the parameters are entered the user clicks a Run button (not shown in the screenshot). When the results are ready they can be viewed by clicking the Output tab at the top of the screen, as shown in the example below. ROI Curves The top part of the window is where ROI curves will be displayed. If more than one goal was specified there is a summary, labeled \"Net\", that shows the combined benefits at each budget level. Benefits for individual targets can also be viewed by clicking the tab for that target. Solution Details Below that is a table that provides more detail about the gates identified by the optimization algorithm at each budget level. There is one row for each budget. The table entries for a row show the number of gates included in the optimal solution and the predicted benefit (the units are explained elsewhere in this documentation). If the user clicks on a row in the table the map is updated to highlight the gates that are part of that solution. Documentation Overview Click on any section in the menu bar to the left to read the documentation. User Instructions has a more detailed discussion of how to use the web application, including additional ways of setting budget levels and how to specify weights for the optimization targets. Installation is for systems administrators who want to set up their own web server to run the web application. The Developer section has technical documentation for programmers intereseted in modifying or extending the application.","title":"Introduction"},{"location":"#introduction","text":"River estuaries are transition zones between freshwater and marine ecosystems. They provide essential habitat for both resident and migratory species. Salmon, lamprey, and other species need to access streams and floodplains that are vital for their foraging, spawning, refuge, and rest. For more than 100 years residents of the Oregon coast have created tide gates, levees, and other barriers to help control the tide and protect farm land, roads, building, and other infrastructure. Many of the tide gates are failing and should be replaced with modern designs that meet current fish passage regulations. The Nature Conservancy has developed a decision support system named the Tide Gate Optimization Tool to help landowners and other stakeholders balance the potential gain and costs. The goal is to help users identify \"the best bang for the buck\": given a set of budget levels, which set of barriers will provide the most benefit for each budget?","title":"Introduction"},{"location":"#web-application","text":"This document describes a web interface to the Tide Gate Optimization Tool. The web application is written in Python, using Panel to display a GUI where users can enter optimization parameters. The screenshot below shows the the main interface.","title":"Web Application"},{"location":"#geographic-regions","text":"The first section in the GUI shows the names of the estuaries in the data set. The user simply clicks on next to the river's name to select the region(s) they are interested in. All the gates in the selected regions are displayed on the map on the left side of the GUI.","title":"Geographic Regions"},{"location":"#budget-levels","text":"Potential benefits are often displayed as return on investment (ROI) curves. To produce ROI curves the optimizer needs to be run at several different budget levels. The simplest way to do this is to use the GUI to select a maximum budget level. In the example shown the maximum is set at $5M (short for \"5 million\"). The optimization algorithm will be run 10 times, with budgets varying from $500,000 to $5,000,000 in increments of $500,000.","title":"Budget Levels"},{"location":"#optimization-goals","text":"The last part of the GUI shown in this screenshot lets users specify their priorities (or \"targets\", using the terminology from the optimization algorithm). In this example the user has selected three different goals -- improving habitat for two species of fish and protecting farmland (or other acreage) in the inundation zone. The optimization algorithm will take all of them into account as it selects the optimal set of gates.","title":"Optimization Goals"},{"location":"#outputs","text":"When all the parameters are entered the user clicks a Run button (not shown in the screenshot). When the results are ready they can be viewed by clicking the Output tab at the top of the screen, as shown in the example below.","title":"Outputs"},{"location":"#roi-curves","text":"The top part of the window is where ROI curves will be displayed. If more than one goal was specified there is a summary, labeled \"Net\", that shows the combined benefits at each budget level. Benefits for individual targets can also be viewed by clicking the tab for that target.","title":"ROI Curves"},{"location":"#solution-details","text":"Below that is a table that provides more detail about the gates identified by the optimization algorithm at each budget level. There is one row for each budget. The table entries for a row show the number of gates included in the optimal solution and the predicted benefit (the units are explained elsewhere in this documentation). If the user clicks on a row in the table the map is updated to highlight the gates that are part of that solution.","title":"Solution Details"},{"location":"#documentation-overview","text":"Click on any section in the menu bar to the left to read the documentation. User Instructions has a more detailed discussion of how to use the web application, including additional ways of setting budget levels and how to specify weights for the optimization targets. Installation is for systems administrators who want to set up their own web server to run the web application. The Developer section has technical documentation for programmers intereseted in modifying or extending the application.","title":"Documentation Overview"},{"location":"app/","text":"TideGatesApp Bases: BootstrapTemplate The web application is based on the Bootstrap template provided by Panel. It displays a map (an instance of the TGMap class) in the sidebar. The main content area has a Tabs widget with five tabs: a welcome message, a help page, the main page (described below) and two tabs for displaying outputs. The application also displays several small help buttons next to the main widgets. Clicking one of these buttons brings up a floating window with information about the widget. The main tab (labeled \"Start\") displays the widgets that allow the user to specify optimization parameters: region names, budget levels, and restoration targets. It also has a Run button. When the user clicks this button the callback function makes sure the necessary parameters have been defined and then uses the template's modal dialog area. Clicking the \"OK\" button in that dialog invokes another callback, defined here, that runs the optimizer. Parameters: params \u2013 runtime options passed to the parent class constructor Source code in src/tidegates/widgets.py 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 def __init__ ( self , ** params ): \"\"\" Initialize the application. Arguments: params: runtime options passed to the parent class constructor \"\"\" super ( TideGatesApp , self ) . __init__ ( ** params ) self . bf = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) self . map = TGMap ( self . bf ) self . map_pane = pn . panel ( self . map . graphic ()) self . budget_box = BudgetBox () self . region_boxes = RegionBox ( self . bf , self . map , self . budget_box ) self . target_boxes = TargetBox () self . climate_group = pn . widgets . RadioBoxGroup ( name = 'Climate' , options = self . bf . climates ) self . optimize_button = pn . widgets . Button ( name = 'Run Optimizer' , stylesheets = [ button_style_sheet ]) self . info = InfoBox ( self , self . run_optimizer ) self . map_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . map_help_button . on_click ( self . map_help_cb ) self . region_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . region_help_button . on_click ( self . region_help_cb ) self . budget_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . budget_help_button . on_click ( self . budget_help_cb ) self . target_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . target_help_button . on_click ( self . target_help_cb ) self . climate_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . climate_help_button . on_click ( self . climate_help_cb ) welcome_tab = pn . Column ( self . section_head ( 'Welcome' ), pn . pane . HTML ( open ( 'static/welcome.html' ) . read ()), ) help_tab = pn . Column ( self . section_head ( 'Instructions' ), pn . pane . HTML ( open ( 'static/help1.html' ) . read ()), pn . pane . PNG ( 'static/ROI.png' , width = 400 ), pn . pane . HTML ( open ( 'static/help2.html' ) . read ()), ) start_tab = pn . Column ( self . section_head ( 'Geographic Regions' , self . region_help_button ), pn . WidgetBox ( self . region_boxes , width = 600 ), self . section_head ( 'Budget' , self . budget_help_button ), self . budget_box , self . section_head ( 'Targets' , self . target_help_button ), pn . WidgetBox ( pn . Row ( self . target_boxes , pn . Column ( self . section_head ( 'Climate' , self . climate_help_button ), self . climate_group , margin = ( 0 , 0 , 0 , 20 ), ), ), width = 600 , ), self . optimize_button , ) output_tab = pn . Column ( self . section_head ( 'Nothing to See Yet' ), pn . pane . HTML ( '<p>After running the optimizer this tab will show the results.</p>' ) ) download_tab = pn . Column ( self . section_head ( 'Nothing to Download Yet' ), pn . pane . HTML ( '<p>After running the optimizer use this tab to save the results.</p>' ) ) self . tabs = pn . Tabs ( ( 'Home' , welcome_tab ), ( 'Help' , help_tab ), ( 'Start' , start_tab ), ( 'Output' , output_tab ), ( 'Download' , download_tab ), sizing_mode = 'fixed' , width = 800 , # height=700, ) self . sidebar . append ( pn . Row ( self . map_pane , self . map_help_button )) self . main . append ( self . tabs ) self . info = InfoBox ( self , self . run_optimizer ) self . modal . append ( self . info ) self . optimize_button . on_click ( self . validate_settings ) section_head ( s , b = None ) Create an HTML header for one of the sections in the Start tab. src/tidegates/widgets.py 938 939 940 941 942 943 def section_head ( self , s , b = None ): \"\"\" Create an HTML header for one of the sections in the Start tab. \"\"\" header = pn . pane . HTML ( f '<h3> { s } </h3>' , styles = header_styles ) return header if b is None else pn . Row ( header , b ) validate_settings ( _ ) Callback function invoked when the user clicks the Run Optimizer button. src/tidegates/widgets.py 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 def validate_settings ( self , _ ): \"\"\" Callback function invoked when the user clicks the Run Optimizer button. \"\"\" regions = self . region_boxes . selection () budget_max , budget_delta = self . budget_box . values () targets = self . target_boxes . selection () if len ( regions ) == 0 or budget_max == 0 or len ( targets ) == 0 : self . info . show_missing ( regions , budget_max , targets ) return if weights := self . target_boxes . weights (): if not all ([ w . isdigit () and ( 1 <= int ( w ) <= 5 ) for w in weights ]): self . info . show_invalid_weights ( weights ) return self . info . show_params ( regions , budget_max , budget_delta , targets , weights , self . climate_group . value ) run_optimizer ( _ ) Callback function invoked when the user clicks the Continue button after verifying the parameter options. Use the settings in the budget widgets to figure out the sequence of budget levels to use. Instantiate an OP object with the budget settings and values from the other parameter widgets, then use that widget to run OptiPass. src/tidegates/widgets.py 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 def run_optimizer ( self , _ ): \"\"\" Callback function invoked when the user clicks the Continue button after verifying the parameter options. Use the settings in the budget widgets to figure out the sequence of budget levels to use. Instantiate an OP object with the budget settings and values from the other parameter widgets, then use that widget to run OptiPass. \"\"\" Logging . log ( 'running optimizer' ) self . close_modal () self . main [ 0 ] . loading = True budget_max , budget_delta = self . budget_box . values () num_budgets = budget_max // budget_delta self . op = OP ( self . bf , list ( self . region_boxes . selection ()), [ self . bf . target_map [ t ] for t in self . target_boxes . selection ()], self . target_boxes . weights (), self . climate_group . value , ) self . op . generate_input_frame () self . op . run ( self . budget_box . values (), False ) self . main [ 0 ] . loading = False # If OP ran successfully we expect to find one file for each budget level # plus one more for the $0 budget try : Logging . log ( 'runs complete' ) if self . op . outputs is None or len ( self . op . outputs ) != num_budgets + 1 : raise ( RuntimeError ( 'Missing output files' )) self . op . collect_results ( False ) Logging . log ( 'Output files:' + ',' . join ( self . op . outputs )) self . info . show_success () self . add_output_pane () except RuntimeError as err : print ( err ) self . info . show_fail ( err ) add_output_pane ( op = None ) After running OptiPass call this method to add tabs to the main panel to show the results. Parameters: op \u2013 an optional Project object used by integration tests (if no argument is passed use the Project option defined for the application) src/tidegates/widgets.py 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 def add_output_pane ( self , op = None ): \"\"\" After running OptiPass call this method to add tabs to the main panel to show the results. Arguments: op: an optional Project object used by integration tests (if no argument is passed use the Project option defined for the application) \"\"\" op = op or self . op output = OutputPane ( op , self . bf ) output . make_dots ( self . map . graphic ()) self . region_boxes . add_external_callback ( output . hide_dots ) self . tabs [ 3 ] = ( 'Output' , output ) self . tabs [ 4 ] = ( 'Download' , DownloadPane ( output )) map_help_cb ( _ ) Callback function for the help button next to the map in the sidebar. src/tidegates/widgets.py 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 def map_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the map in the sidebar. \"\"\" msg = pn . pane . HTML ( ''' <p>When you move your mouse over the map the cursor will change to a \"crosshairs\" symbol and a set of buttons will appear below the map. Navigating with the map is similar to using Google maps or other online maps:</p> <ul> <li>Left-click and drag to pan (move left and right or up and down).</li> <li>If you want to zoom in and out, first click the magnifying glass button below the map; then you can zoom in and out using the scroll wheel on your mouse.</li> <li>Click the refresh button to restore the map to its original size and location.</li> </ul> ''' ) self . tabs [ 0 ] . append ( pn . layout . FloatPanel ( msg , name = 'Map Controls' , contained = False , position = 'center' , width = 400 )) region_help_cb ( _ ) Callback function for the help button next to the region box widget in the start tab. src/tidegates/widgets.py 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 def region_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the region box widget in the start tab. \"\"\" msg = pn . pane . HTML ( ''' <p>Select a region by clicking in the box to the left of an estuary name.</p> <p>Each time you click in a box the map will be updated to show the positions of the barriers that are in our database for the estuary.</p> <p>You must select at least one region before you run the optimizer.</p> ''' ) self . tabs [ 2 ] . append ( pn . layout . FloatPanel ( msg , name = 'Geographic Regions' , contained = False , position = 'center' , width = 400 )) budget_help_cb ( _ ) Callback function for the help button next to the budget box widget in the start tab. src/tidegates/widgets.py 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 def budget_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the budget box widget in the start tab. \"\"\" msg = pn . pane . HTML ( ''' <p>There are three ways to specify the budgets used by the optimizer.</p> <H4>Basic</H4> <p>The simplest method is to specify an upper limit by moving the slider back and forth. When you use this method, the optimizer will run 10 times, ending at the value you select with the slider. For example, if you set the slider at $10M (the abbreviation for $10 million), the optimizer will make ROI curves based on budgets of $1M, $2M, <i>etc</i>, up to the maximum of $10M.</p> <p>Note that the slider is disabled until you select one or more regions. That's because the maximum value depends on the costs of the gates in each region. For example, the total cost of all gates in the Coquille region is $11.8M. Once you choose that region, you can move the budget slider left and right to pick a maximum budget for the optimizer to consider. <H4>Advanced</H4> <p>If you click on the Advanced tab in this section you will see ways to specify the budget interval and the number of budgets.</p> <p>You can use this method if you want more control over the layout of the ROI curves, for example you can include more points by increasing the number of budgets.</p> <H4>Fixed</H4> <p>If you know exactly how much money you have to spend you can enter that amount by clicking on the Fixed tab and entering the budget amount.</p> <p>The optimizer will run just once, using that budget. The output will have tables showing the gates identified by the optimizer, but there will be no ROI curve.</p> <p>When entering values, you can write the full amount, with or without commas (<i>e.g.</i>11,500,000 or 11500000) or use the abbreviated form (11.5M).</p> ''' ) self . tabs [ 2 ] . append ( pn . layout . FloatPanel ( msg , name = 'Budget Levels' , contained = False , position = 'center' , width = 400 )) target_help_cb ( _ ) Callback function for the help button next to the target box widget in the start tab. src/tidegates/widgets.py 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 def target_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the target box widget in the start tab. \"\"\" msg = pn . pane . HTML ( ''' <p>Click boxes next to one or more target names to have the optimizer include those targets in its calculations.</p> <p>The optimizer will create an ROI curve for each target selected. </p> <p>If more than one target is selected the optimizer will also generate an overall \"net benefit\" curve based on considering all targets at the same time.</p> ''' ) self . tabs [ 2 ] . append ( pn . layout . FloatPanel ( msg , name = 'Targets' , contained = False , position = 'center' , width = 400 )) climate_help_cb ( _ ) Callback function for the help button next to the climate scenario checkbox in the start tab. src/tidegates/widgets.py 1086 1087 1088 1089 1090 1091 1092 1093 1094 def climate_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the climate scenario checkbox in the start tab. \"\"\" msg = pn . pane . HTML ( ''' <p>By default the optimizer uses current water levels when computing potential benefits. Click the button next to <b>Future</b> to have it use water levels expected due to climate change.</p> <p>The future scenario uses two projected water levels, both for the period to 2100. For fish habitat targets, the future water level is based on projected sea level rise of 5.0 feet. For agriculture and infrastructure targets, the future water level is projected to be 7.2 feet, which includes sea level rise and the probabilities of extreme water levels causing flooding events.</p> ''' ) self . tabs [ 2 ] . append ( pn . layout . FloatPanel ( msg , name = 'Targets' , contained = False , position = 'center' , width = 400 ))","title":"TideGatesApp"},{"location":"app/#tidegatesapp","text":"Bases: BootstrapTemplate The web application is based on the Bootstrap template provided by Panel. It displays a map (an instance of the TGMap class) in the sidebar. The main content area has a Tabs widget with five tabs: a welcome message, a help page, the main page (described below) and two tabs for displaying outputs. The application also displays several small help buttons next to the main widgets. Clicking one of these buttons brings up a floating window with information about the widget. The main tab (labeled \"Start\") displays the widgets that allow the user to specify optimization parameters: region names, budget levels, and restoration targets. It also has a Run button. When the user clicks this button the callback function makes sure the necessary parameters have been defined and then uses the template's modal dialog area. Clicking the \"OK\" button in that dialog invokes another callback, defined here, that runs the optimizer. Parameters: params \u2013 runtime options passed to the parent class constructor Source code in src/tidegates/widgets.py 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 def __init__ ( self , ** params ): \"\"\" Initialize the application. Arguments: params: runtime options passed to the parent class constructor \"\"\" super ( TideGatesApp , self ) . __init__ ( ** params ) self . bf = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) self . map = TGMap ( self . bf ) self . map_pane = pn . panel ( self . map . graphic ()) self . budget_box = BudgetBox () self . region_boxes = RegionBox ( self . bf , self . map , self . budget_box ) self . target_boxes = TargetBox () self . climate_group = pn . widgets . RadioBoxGroup ( name = 'Climate' , options = self . bf . climates ) self . optimize_button = pn . widgets . Button ( name = 'Run Optimizer' , stylesheets = [ button_style_sheet ]) self . info = InfoBox ( self , self . run_optimizer ) self . map_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . map_help_button . on_click ( self . map_help_cb ) self . region_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . region_help_button . on_click ( self . region_help_cb ) self . budget_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . budget_help_button . on_click ( self . budget_help_cb ) self . target_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . target_help_button . on_click ( self . target_help_cb ) self . climate_help_button = pn . widgets . Button ( name = '\u2139\ufe0f' , stylesheets = [ help_button_style_sheet ]) self . climate_help_button . on_click ( self . climate_help_cb ) welcome_tab = pn . Column ( self . section_head ( 'Welcome' ), pn . pane . HTML ( open ( 'static/welcome.html' ) . read ()), ) help_tab = pn . Column ( self . section_head ( 'Instructions' ), pn . pane . HTML ( open ( 'static/help1.html' ) . read ()), pn . pane . PNG ( 'static/ROI.png' , width = 400 ), pn . pane . HTML ( open ( 'static/help2.html' ) . read ()), ) start_tab = pn . Column ( self . section_head ( 'Geographic Regions' , self . region_help_button ), pn . WidgetBox ( self . region_boxes , width = 600 ), self . section_head ( 'Budget' , self . budget_help_button ), self . budget_box , self . section_head ( 'Targets' , self . target_help_button ), pn . WidgetBox ( pn . Row ( self . target_boxes , pn . Column ( self . section_head ( 'Climate' , self . climate_help_button ), self . climate_group , margin = ( 0 , 0 , 0 , 20 ), ), ), width = 600 , ), self . optimize_button , ) output_tab = pn . Column ( self . section_head ( 'Nothing to See Yet' ), pn . pane . HTML ( '<p>After running the optimizer this tab will show the results.</p>' ) ) download_tab = pn . Column ( self . section_head ( 'Nothing to Download Yet' ), pn . pane . HTML ( '<p>After running the optimizer use this tab to save the results.</p>' ) ) self . tabs = pn . Tabs ( ( 'Home' , welcome_tab ), ( 'Help' , help_tab ), ( 'Start' , start_tab ), ( 'Output' , output_tab ), ( 'Download' , download_tab ), sizing_mode = 'fixed' , width = 800 , # height=700, ) self . sidebar . append ( pn . Row ( self . map_pane , self . map_help_button )) self . main . append ( self . tabs ) self . info = InfoBox ( self , self . run_optimizer ) self . modal . append ( self . info ) self . optimize_button . on_click ( self . validate_settings )","title":"TideGatesApp"},{"location":"app/#src.tidegates.widgets.TideGatesApp.section_head","text":"Create an HTML header for one of the sections in the Start tab. src/tidegates/widgets.py 938 939 940 941 942 943 def section_head ( self , s , b = None ): \"\"\" Create an HTML header for one of the sections in the Start tab. \"\"\" header = pn . pane . HTML ( f '<h3> { s } </h3>' , styles = header_styles ) return header if b is None else pn . Row ( header , b )","title":"section_head()"},{"location":"app/#src.tidegates.widgets.TideGatesApp.validate_settings","text":"Callback function invoked when the user clicks the Run Optimizer button. src/tidegates/widgets.py 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 def validate_settings ( self , _ ): \"\"\" Callback function invoked when the user clicks the Run Optimizer button. \"\"\" regions = self . region_boxes . selection () budget_max , budget_delta = self . budget_box . values () targets = self . target_boxes . selection () if len ( regions ) == 0 or budget_max == 0 or len ( targets ) == 0 : self . info . show_missing ( regions , budget_max , targets ) return if weights := self . target_boxes . weights (): if not all ([ w . isdigit () and ( 1 <= int ( w ) <= 5 ) for w in weights ]): self . info . show_invalid_weights ( weights ) return self . info . show_params ( regions , budget_max , budget_delta , targets , weights , self . climate_group . value )","title":"validate_settings()"},{"location":"app/#src.tidegates.widgets.TideGatesApp.run_optimizer","text":"Callback function invoked when the user clicks the Continue button after verifying the parameter options. Use the settings in the budget widgets to figure out the sequence of budget levels to use. Instantiate an OP object with the budget settings and values from the other parameter widgets, then use that widget to run OptiPass. src/tidegates/widgets.py 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 def run_optimizer ( self , _ ): \"\"\" Callback function invoked when the user clicks the Continue button after verifying the parameter options. Use the settings in the budget widgets to figure out the sequence of budget levels to use. Instantiate an OP object with the budget settings and values from the other parameter widgets, then use that widget to run OptiPass. \"\"\" Logging . log ( 'running optimizer' ) self . close_modal () self . main [ 0 ] . loading = True budget_max , budget_delta = self . budget_box . values () num_budgets = budget_max // budget_delta self . op = OP ( self . bf , list ( self . region_boxes . selection ()), [ self . bf . target_map [ t ] for t in self . target_boxes . selection ()], self . target_boxes . weights (), self . climate_group . value , ) self . op . generate_input_frame () self . op . run ( self . budget_box . values (), False ) self . main [ 0 ] . loading = False # If OP ran successfully we expect to find one file for each budget level # plus one more for the $0 budget try : Logging . log ( 'runs complete' ) if self . op . outputs is None or len ( self . op . outputs ) != num_budgets + 1 : raise ( RuntimeError ( 'Missing output files' )) self . op . collect_results ( False ) Logging . log ( 'Output files:' + ',' . join ( self . op . outputs )) self . info . show_success () self . add_output_pane () except RuntimeError as err : print ( err ) self . info . show_fail ( err )","title":"run_optimizer()"},{"location":"app/#src.tidegates.widgets.TideGatesApp.add_output_pane","text":"After running OptiPass call this method to add tabs to the main panel to show the results. Parameters: op \u2013 an optional Project object used by integration tests (if no argument is passed use the Project option defined for the application) src/tidegates/widgets.py 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 def add_output_pane ( self , op = None ): \"\"\" After running OptiPass call this method to add tabs to the main panel to show the results. Arguments: op: an optional Project object used by integration tests (if no argument is passed use the Project option defined for the application) \"\"\" op = op or self . op output = OutputPane ( op , self . bf ) output . make_dots ( self . map . graphic ()) self . region_boxes . add_external_callback ( output . hide_dots ) self . tabs [ 3 ] = ( 'Output' , output ) self . tabs [ 4 ] = ( 'Download' , DownloadPane ( output ))","title":"add_output_pane()"},{"location":"app/#src.tidegates.widgets.TideGatesApp.map_help_cb","text":"Callback function for the help button next to the map in the sidebar. src/tidegates/widgets.py 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 def map_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the map in the sidebar. \"\"\" msg = pn . pane . HTML ( ''' <p>When you move your mouse over the map the cursor will change to a \"crosshairs\" symbol and a set of buttons will appear below the map. Navigating with the map is similar to using Google maps or other online maps:</p> <ul> <li>Left-click and drag to pan (move left and right or up and down).</li> <li>If you want to zoom in and out, first click the magnifying glass button below the map; then you can zoom in and out using the scroll wheel on your mouse.</li> <li>Click the refresh button to restore the map to its original size and location.</li> </ul> ''' ) self . tabs [ 0 ] . append ( pn . layout . FloatPanel ( msg , name = 'Map Controls' , contained = False , position = 'center' , width = 400 ))","title":"map_help_cb()"},{"location":"app/#src.tidegates.widgets.TideGatesApp.region_help_cb","text":"Callback function for the help button next to the region box widget in the start tab. src/tidegates/widgets.py 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 def region_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the region box widget in the start tab. \"\"\" msg = pn . pane . HTML ( ''' <p>Select a region by clicking in the box to the left of an estuary name.</p> <p>Each time you click in a box the map will be updated to show the positions of the barriers that are in our database for the estuary.</p> <p>You must select at least one region before you run the optimizer.</p> ''' ) self . tabs [ 2 ] . append ( pn . layout . FloatPanel ( msg , name = 'Geographic Regions' , contained = False , position = 'center' , width = 400 ))","title":"region_help_cb()"},{"location":"app/#src.tidegates.widgets.TideGatesApp.budget_help_cb","text":"Callback function for the help button next to the budget box widget in the start tab. src/tidegates/widgets.py 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 def budget_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the budget box widget in the start tab. \"\"\" msg = pn . pane . HTML ( ''' <p>There are three ways to specify the budgets used by the optimizer.</p> <H4>Basic</H4> <p>The simplest method is to specify an upper limit by moving the slider back and forth. When you use this method, the optimizer will run 10 times, ending at the value you select with the slider. For example, if you set the slider at $10M (the abbreviation for $10 million), the optimizer will make ROI curves based on budgets of $1M, $2M, <i>etc</i>, up to the maximum of $10M.</p> <p>Note that the slider is disabled until you select one or more regions. That's because the maximum value depends on the costs of the gates in each region. For example, the total cost of all gates in the Coquille region is $11.8M. Once you choose that region, you can move the budget slider left and right to pick a maximum budget for the optimizer to consider. <H4>Advanced</H4> <p>If you click on the Advanced tab in this section you will see ways to specify the budget interval and the number of budgets.</p> <p>You can use this method if you want more control over the layout of the ROI curves, for example you can include more points by increasing the number of budgets.</p> <H4>Fixed</H4> <p>If you know exactly how much money you have to spend you can enter that amount by clicking on the Fixed tab and entering the budget amount.</p> <p>The optimizer will run just once, using that budget. The output will have tables showing the gates identified by the optimizer, but there will be no ROI curve.</p> <p>When entering values, you can write the full amount, with or without commas (<i>e.g.</i>11,500,000 or 11500000) or use the abbreviated form (11.5M).</p> ''' ) self . tabs [ 2 ] . append ( pn . layout . FloatPanel ( msg , name = 'Budget Levels' , contained = False , position = 'center' , width = 400 ))","title":"budget_help_cb()"},{"location":"app/#src.tidegates.widgets.TideGatesApp.target_help_cb","text":"Callback function for the help button next to the target box widget in the start tab. src/tidegates/widgets.py 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 def target_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the target box widget in the start tab. \"\"\" msg = pn . pane . HTML ( ''' <p>Click boxes next to one or more target names to have the optimizer include those targets in its calculations.</p> <p>The optimizer will create an ROI curve for each target selected. </p> <p>If more than one target is selected the optimizer will also generate an overall \"net benefit\" curve based on considering all targets at the same time.</p> ''' ) self . tabs [ 2 ] . append ( pn . layout . FloatPanel ( msg , name = 'Targets' , contained = False , position = 'center' , width = 400 ))","title":"target_help_cb()"},{"location":"app/#src.tidegates.widgets.TideGatesApp.climate_help_cb","text":"Callback function for the help button next to the climate scenario checkbox in the start tab. src/tidegates/widgets.py 1086 1087 1088 1089 1090 1091 1092 1093 1094 def climate_help_cb ( self , _ ): \"\"\" Callback function for the help button next to the climate scenario checkbox in the start tab. \"\"\" msg = pn . pane . HTML ( ''' <p>By default the optimizer uses current water levels when computing potential benefits. Click the button next to <b>Future</b> to have it use water levels expected due to climate change.</p> <p>The future scenario uses two projected water levels, both for the period to 2100. For fish habitat targets, the future water level is based on projected sea level rise of 5.0 feet. For agriculture and infrastructure targets, the future water level is projected to be 7.2 feet, which includes sea level rise and the probabilities of extreme water levels causing flooding events.</p> ''' ) self . tabs [ 2 ] . append ( pn . layout . FloatPanel ( msg , name = 'Targets' , contained = False , position = 'center' , width = 400 ))","title":"climate_help_cb()"},{"location":"budgets/","text":"BudgetBox The widget that displays budget options is an instance of a class named BudgetBox . It has a set of three tabs that display different options for specifying a budget: the default view is a slider that sets the maximum budget value; OptiPass will be run 10 times with budgets ranging from 0 up to the maximum an advanced view allows users to set the maximum, the interval between budgets, and the total number of budgets to consider the fixed view has a text entry widget there the user enters a budget, Optipass will be run once using this budget The BudgetBox class and the three budget views are all defined in src/budgets.py . There are three ways users can specify the range of budget values when running OptiPass. A BudgetBox widget has one tab for each option. The widgets displayed inside a tab are defined by their own classes (BasicBudgetBox, AdvancedBudgetBox, and FixedBudgetBox). Source code in src/tidegates/budgets.py 19 20 21 22 23 24 25 26 def __init__ ( self ): super ( BudgetBox , self ) . __init__ () self . tabs = pn . Tabs ( ( 'Basic' , BasicBudgetBox ()), ( 'Advanced' , AdvancedBudgetBox ()), ( 'Fixed' , FixedBudgetBox ()), ) self . append ( self . tabs ) set_budget_max ( n ) When the user selects or deselects a region the budget widgets need to know the new total cost for all the selected regions. This method passes that information to each of the budget widgets. Parameters: n ( int ) \u2013 the new maximum budget amount src/tidegates/budgets.py 28 29 30 31 32 33 34 35 36 37 38 def set_budget_max ( self , n : int ): \"\"\" When the user selects or deselects a region the budget widgets need to know the new total cost for all the selected regions. This method passes that information to each of the budget widgets. Arguments: n: the new maximum budget amount \"\"\" for t in self . tabs : t . set_budget_max ( n ) values () Return the budget settings for the currently selected budget type. Returns: bmax \u2013 the maximum budget to pass to OptiPass binc \u2013 the increment between budget values src/tidegates/budgets.py 40 41 42 43 44 45 46 47 48 def values ( self ): \"\"\" Return the budget settings for the currently selected budget type. Returns: bmax: the maximum budget to pass to OptiPass binc: the increment between budget values \"\"\" return self . tabs [ self . tabs . active ] . values () BasicBudgetBox The default budget widget displays a slider that ranges from 0 up to a maximum value based on the total cost of all barriers in currently selected regions. Source code in src/tidegates/budgets.py 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self ): super ( BasicBudgetBox , self ) . __init__ ( margin = ( 15 , 0 , 15 , 5 )) self . labels = [ x [ 0 ] for x in self . levels ] self . map = { x [ 0 ]: x [ 1 ] for x in self . levels } self . slider = pn . widgets . DiscreteSlider ( options = self . labels [: 1 ], value = self . labels [ 0 ], name = 'Maximum Budget' , margin = ( 20 , 20 , 20 , 20 ), stylesheets = [ slider_style_sheet ], ) self . append ( self . slider ) set_budget_max ( n ) Choose a maximum budget by scanning a table of budget levels to find the first one less than the total cost. Parameters: n \u2013 the total cost of all barriers in the current selection. src/tidegates/budgets.py 85 86 87 88 89 90 91 92 93 94 95 96 def set_budget_max ( self , n ): \"\"\" Choose a maximum budget by scanning a table of budget levels to find the first one less than the total cost. Arguments: n: the total cost of all barriers in the current selection. \"\"\" for i in range ( len ( self . levels ) - 1 , - 1 , - 1 ): if n >= self . levels [ i ][ 1 ]: self . slider . options = self . labels [: i + 1 ] break values () Return the selected budget level (based on the slider position) and the number of budgets. For basic budgets the interval between budgets is computed by dividing the select budget value by the number of increments (a constant defined in the class, currently equal to 10). Returns: bmax \u2013 the highest budget to pass to OptiPass binc \u2013 the increment between budgets src/tidegates/budgets.py 98 99 100 101 102 103 104 105 106 107 108 109 110 def values ( self ): \"\"\" Return the selected budget level (based on the slider position) and the number of budgets. For basic budgets the interval between budgets is computed by dividing the select budget value by the number of increments (a constant defined in the class, currently equal to 10). Returns: bmax: the highest budget to pass to OptiPass binc: the increment between budgets \"\"\" x = self . map [ self . slider . value ] return x , ( x // self . increments ) AdvancedBudgetBox The \"advanced\" option gives the user the most control over the budget values processed by OptiPass by letting them specify the number of budget levels (in the basic budget there are always 10 budget levels). This box has three widgets: a slider to specify the maximum amount, another slider to specify the increment between budgets, and an input box to specify the number of budgets. Adjusting the value of any of these widgets automatically updates the other two. For example, if the maximum is set to $1M and the number of budgets is 10, the increment is $100K. If the user changes the number of budgets to 20, the increment drops to $50K. Or if they change the maximum to $2M, the increment increases to $200K. Source code in src/tidegates/budgets.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def __init__ ( self ): super ( AdvancedBudgetBox , self ) . __init__ ( margin = ( 15 , 0 , 15 , 5 )) self . cap = 0 self . max_slider = pn . widgets . FloatSlider ( name = 'Maximum Budget' , start = 0 , end = 1 , step = self . MAX_STEP , value = 0 , width = self . SLIDER_WIDTH , format = NumeralTickFormatter ( format = '$0,0' ), stylesheets = [ slider_style_sheet ], ) self . inc_slider = pn . widgets . FloatSlider ( name = 'Budget Interval' , start = 0 , end = 1 , step = self . INC_STEP , value = 0 , width = self . SLIDER_WIDTH // 2 , format = NumeralTickFormatter ( format = '$0,0' ), stylesheets = [ slider_style_sheet ], ) self . count_input = pn . widgets . IntInput ( name = 'Number of Budgets' , value = 10 , step = 1 , start = self . COUNT_MIN , end = self . COUNT_MAX , width = 75 , ) self . append ( pn . Row ( self . max_slider , pn . pane . HTML ( '<b>Limit: N/A<b>' ))) self . append ( pn . Row ( self . inc_slider , self . count_input )) self . max_slider . param . watch ( self . max_updated , [ 'value' ]) self . inc_slider . param . watch ( self . inc_updated , [ 'value' ]) self . count_input . param . watch ( self . count_updated , [ 'value' ]) count_updated ( e ) Callback function invoked when the user changes the number of budget levels. Computes a new budget increment. src/tidegates/budgets.py 273 274 275 276 277 278 def count_updated ( self , e ): \"\"\" Callback function invoked when the user changes the number of budget levels. Computes a new budget increment. \"\"\" self . inc_slider . value = self . max_slider . value // self . count_input . value inc_updated ( e ) Callback function invoked when the user changes the budget increment. Computes a new number of budgets. src/tidegates/budgets.py 264 265 266 267 268 269 270 271 def inc_updated ( self , e ): \"\"\" Callback function invoked when the user changes the budget increment. Computes a new number of budgets. \"\"\" c = max ( self . COUNT_MIN , self . max_slider . value // self . inc_slider . value ) c = min ( self . COUNT_MAX , c ) self . count_input . value = c max_updated ( e ) Callback function invoked when the user moves the maximum budget slider. Computes a new budget increment. src/tidegates/budgets.py 257 258 259 260 261 262 def max_updated ( self , e ): \"\"\" Callback function invoked when the user moves the maximum budget slider. Computes a new budget increment. \"\"\" self . inc_slider . value = self . max_slider . value // self . count_input . value set_budget_max ( n ) Called when the user selects or deselects a region. Save the new maximum, and update the value of the increment based on the new maximum. Parameters: n \u2013 the total cost of all barriers in the selected regions. src/tidegates/budgets.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 def set_budget_max ( self , n ): \"\"\" Called when the user selects or deselects a region. Save the new maximum, and update the value of the increment based on the new maximum. Arguments: n: the total cost of all barriers in the selected regions. \"\"\" self . max_slider . end = max ( 1 , n ) self . max_slider . start = self . MAX_STEP self . inc_slider . end = max ( 1 , n // 2 ) self . inc_slider . start = max ( self . INC_STEP , n / self . COUNT_MAX ) lim = 'N/A' if n == 0 else f '$ { n / 1000000 : .2f } M' self [ 0 ][ 1 ] = pn . pane . HTML ( f '<b>Limit: { lim } </b>' ) values () In this widget the maximum budget and budget increment are determined by the values in the corresponding widgets. src/tidegates/budgets.py 235 236 237 238 239 240 def values ( self ): \"\"\" In this widget the maximum budget and budget increment are determined by the values in the corresponding widgets. \"\"\" return self . max_slider . value , self . inc_slider . value FixedBudgetBox This option is for situations where a user knows exactly how much money they have to spend and want to know the optimal set of barriers to replace for that amount of money. OptiPass is run twice -- once to determine the current passabilities, and once to compute the benefit from the specified budget. The widget simply displays a box where the user enters the dollar amount for their budget. Source code in src/tidegates/budgets.py 122 123 124 125 def __init__ ( self ): super ( FixedBudgetBox , self ) . __init__ ( margin = ( 15 , 0 , 15 , 5 )) self . input = pn . widgets . TextInput ( name = 'Budget Amount' , value = '$' ) self . append ( self . input ) parse_dollar_amount ( s ) Make sure the string entered by the user has an acceptable format. It can be all digits (e.g. \"1500000\"), or digits separated by commas (e.g. \"1,500,000\"), or a number followed by a K or M (e.g. \"1.5M\"). There can be a dollar sign at the front of the string. Parameters: s ( str ) \u2013 the string entered into the text box Returns: \u2013 the value of the string converted into an integer src/tidegates/budgets.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def parse_dollar_amount ( self , s : str ): \"\"\" Make sure the string entered by the user has an acceptable format. It can be all digits (e.g. \"1500000\"), or digits separated by commas (e.g. \"1,500,000\"), or a number followed by a K or M (e.g. \"1.5M\"). There can be a dollar sign at the front of the string. Arguments: s: the string entered into the text box Returns: the value of the string converted into an integer \"\"\" try : if s . startswith ( '$' ): s = s [ 1 :] if s . endswith (( 'K' , 'M' )): multiplier = 1000 if s . endswith ( 'K' ) else 1000000 res = int ( float ( s [: - 1 ]) * multiplier ) elif ',' in s : parts = s . split ( ',' ) assert len ( parts [ 0 ]) <= 3 and ( len ( parts ) == 1 or all ( len ( p ) == 3 for p in parts [ 1 :])) res = int ( '' . join ( parts )) else : res = int ( s ) return res except Exception : raise ValueError ( 'unexpected format in dollar amount' ) values () Return the specified budget amount as both the maximum budget and the budget interval. src/tidegates/budgets.py 130 131 132 133 134 135 136 137 138 139 def values ( self ): \"\"\" Return the specified budget amount as both the maximum budget and the budget interval. \"\"\" s = self . input . value if s . startswith ( '$' ): s = s [ 1 :] n = self . parse_dollar_amount ( self . input . value ) return n , n","title":"BudgetBox"},{"location":"budgets/#budgetbox","text":"The widget that displays budget options is an instance of a class named BudgetBox . It has a set of three tabs that display different options for specifying a budget: the default view is a slider that sets the maximum budget value; OptiPass will be run 10 times with budgets ranging from 0 up to the maximum an advanced view allows users to set the maximum, the interval between budgets, and the total number of budgets to consider the fixed view has a text entry widget there the user enters a budget, Optipass will be run once using this budget The BudgetBox class and the three budget views are all defined in src/budgets.py . There are three ways users can specify the range of budget values when running OptiPass. A BudgetBox widget has one tab for each option. The widgets displayed inside a tab are defined by their own classes (BasicBudgetBox, AdvancedBudgetBox, and FixedBudgetBox). Source code in src/tidegates/budgets.py 19 20 21 22 23 24 25 26 def __init__ ( self ): super ( BudgetBox , self ) . __init__ () self . tabs = pn . Tabs ( ( 'Basic' , BasicBudgetBox ()), ( 'Advanced' , AdvancedBudgetBox ()), ( 'Fixed' , FixedBudgetBox ()), ) self . append ( self . tabs )","title":"BudgetBox"},{"location":"budgets/#src.tidegates.widgets.BudgetBox.set_budget_max","text":"When the user selects or deselects a region the budget widgets need to know the new total cost for all the selected regions. This method passes that information to each of the budget widgets. Parameters: n ( int ) \u2013 the new maximum budget amount src/tidegates/budgets.py 28 29 30 31 32 33 34 35 36 37 38 def set_budget_max ( self , n : int ): \"\"\" When the user selects or deselects a region the budget widgets need to know the new total cost for all the selected regions. This method passes that information to each of the budget widgets. Arguments: n: the new maximum budget amount \"\"\" for t in self . tabs : t . set_budget_max ( n )","title":"set_budget_max()"},{"location":"budgets/#src.tidegates.widgets.BudgetBox.values","text":"Return the budget settings for the currently selected budget type. Returns: bmax \u2013 the maximum budget to pass to OptiPass binc \u2013 the increment between budget values src/tidegates/budgets.py 40 41 42 43 44 45 46 47 48 def values ( self ): \"\"\" Return the budget settings for the currently selected budget type. Returns: bmax: the maximum budget to pass to OptiPass binc: the increment between budget values \"\"\" return self . tabs [ self . tabs . active ] . values ()","title":"values()"},{"location":"budgets/#basicbudgetbox","text":"The default budget widget displays a slider that ranges from 0 up to a maximum value based on the total cost of all barriers in currently selected regions. Source code in src/tidegates/budgets.py 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self ): super ( BasicBudgetBox , self ) . __init__ ( margin = ( 15 , 0 , 15 , 5 )) self . labels = [ x [ 0 ] for x in self . levels ] self . map = { x [ 0 ]: x [ 1 ] for x in self . levels } self . slider = pn . widgets . DiscreteSlider ( options = self . labels [: 1 ], value = self . labels [ 0 ], name = 'Maximum Budget' , margin = ( 20 , 20 , 20 , 20 ), stylesheets = [ slider_style_sheet ], ) self . append ( self . slider )","title":"BasicBudgetBox"},{"location":"budgets/#src.tidegates.budgets.BasicBudgetBox.set_budget_max","text":"Choose a maximum budget by scanning a table of budget levels to find the first one less than the total cost. Parameters: n \u2013 the total cost of all barriers in the current selection. src/tidegates/budgets.py 85 86 87 88 89 90 91 92 93 94 95 96 def set_budget_max ( self , n ): \"\"\" Choose a maximum budget by scanning a table of budget levels to find the first one less than the total cost. Arguments: n: the total cost of all barriers in the current selection. \"\"\" for i in range ( len ( self . levels ) - 1 , - 1 , - 1 ): if n >= self . levels [ i ][ 1 ]: self . slider . options = self . labels [: i + 1 ] break","title":"set_budget_max()"},{"location":"budgets/#src.tidegates.budgets.BasicBudgetBox.values","text":"Return the selected budget level (based on the slider position) and the number of budgets. For basic budgets the interval between budgets is computed by dividing the select budget value by the number of increments (a constant defined in the class, currently equal to 10). Returns: bmax \u2013 the highest budget to pass to OptiPass binc \u2013 the increment between budgets src/tidegates/budgets.py 98 99 100 101 102 103 104 105 106 107 108 109 110 def values ( self ): \"\"\" Return the selected budget level (based on the slider position) and the number of budgets. For basic budgets the interval between budgets is computed by dividing the select budget value by the number of increments (a constant defined in the class, currently equal to 10). Returns: bmax: the highest budget to pass to OptiPass binc: the increment between budgets \"\"\" x = self . map [ self . slider . value ] return x , ( x // self . increments )","title":"values()"},{"location":"budgets/#advancedbudgetbox","text":"The \"advanced\" option gives the user the most control over the budget values processed by OptiPass by letting them specify the number of budget levels (in the basic budget there are always 10 budget levels). This box has three widgets: a slider to specify the maximum amount, another slider to specify the increment between budgets, and an input box to specify the number of budgets. Adjusting the value of any of these widgets automatically updates the other two. For example, if the maximum is set to $1M and the number of budgets is 10, the increment is $100K. If the user changes the number of budgets to 20, the increment drops to $50K. Or if they change the maximum to $2M, the increment increases to $200K. Source code in src/tidegates/budgets.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def __init__ ( self ): super ( AdvancedBudgetBox , self ) . __init__ ( margin = ( 15 , 0 , 15 , 5 )) self . cap = 0 self . max_slider = pn . widgets . FloatSlider ( name = 'Maximum Budget' , start = 0 , end = 1 , step = self . MAX_STEP , value = 0 , width = self . SLIDER_WIDTH , format = NumeralTickFormatter ( format = '$0,0' ), stylesheets = [ slider_style_sheet ], ) self . inc_slider = pn . widgets . FloatSlider ( name = 'Budget Interval' , start = 0 , end = 1 , step = self . INC_STEP , value = 0 , width = self . SLIDER_WIDTH // 2 , format = NumeralTickFormatter ( format = '$0,0' ), stylesheets = [ slider_style_sheet ], ) self . count_input = pn . widgets . IntInput ( name = 'Number of Budgets' , value = 10 , step = 1 , start = self . COUNT_MIN , end = self . COUNT_MAX , width = 75 , ) self . append ( pn . Row ( self . max_slider , pn . pane . HTML ( '<b>Limit: N/A<b>' ))) self . append ( pn . Row ( self . inc_slider , self . count_input )) self . max_slider . param . watch ( self . max_updated , [ 'value' ]) self . inc_slider . param . watch ( self . inc_updated , [ 'value' ]) self . count_input . param . watch ( self . count_updated , [ 'value' ])","title":"AdvancedBudgetBox"},{"location":"budgets/#src.tidegates.budgets.AdvancedBudgetBox.count_updated","text":"Callback function invoked when the user changes the number of budget levels. Computes a new budget increment. src/tidegates/budgets.py 273 274 275 276 277 278 def count_updated ( self , e ): \"\"\" Callback function invoked when the user changes the number of budget levels. Computes a new budget increment. \"\"\" self . inc_slider . value = self . max_slider . value // self . count_input . value","title":"count_updated()"},{"location":"budgets/#src.tidegates.budgets.AdvancedBudgetBox.inc_updated","text":"Callback function invoked when the user changes the budget increment. Computes a new number of budgets. src/tidegates/budgets.py 264 265 266 267 268 269 270 271 def inc_updated ( self , e ): \"\"\" Callback function invoked when the user changes the budget increment. Computes a new number of budgets. \"\"\" c = max ( self . COUNT_MIN , self . max_slider . value // self . inc_slider . value ) c = min ( self . COUNT_MAX , c ) self . count_input . value = c","title":"inc_updated()"},{"location":"budgets/#src.tidegates.budgets.AdvancedBudgetBox.max_updated","text":"Callback function invoked when the user moves the maximum budget slider. Computes a new budget increment. src/tidegates/budgets.py 257 258 259 260 261 262 def max_updated ( self , e ): \"\"\" Callback function invoked when the user moves the maximum budget slider. Computes a new budget increment. \"\"\" self . inc_slider . value = self . max_slider . value // self . count_input . value","title":"max_updated()"},{"location":"budgets/#src.tidegates.budgets.AdvancedBudgetBox.set_budget_max","text":"Called when the user selects or deselects a region. Save the new maximum, and update the value of the increment based on the new maximum. Parameters: n \u2013 the total cost of all barriers in the selected regions. src/tidegates/budgets.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 def set_budget_max ( self , n ): \"\"\" Called when the user selects or deselects a region. Save the new maximum, and update the value of the increment based on the new maximum. Arguments: n: the total cost of all barriers in the selected regions. \"\"\" self . max_slider . end = max ( 1 , n ) self . max_slider . start = self . MAX_STEP self . inc_slider . end = max ( 1 , n // 2 ) self . inc_slider . start = max ( self . INC_STEP , n / self . COUNT_MAX ) lim = 'N/A' if n == 0 else f '$ { n / 1000000 : .2f } M' self [ 0 ][ 1 ] = pn . pane . HTML ( f '<b>Limit: { lim } </b>' )","title":"set_budget_max()"},{"location":"budgets/#src.tidegates.budgets.AdvancedBudgetBox.values","text":"In this widget the maximum budget and budget increment are determined by the values in the corresponding widgets. src/tidegates/budgets.py 235 236 237 238 239 240 def values ( self ): \"\"\" In this widget the maximum budget and budget increment are determined by the values in the corresponding widgets. \"\"\" return self . max_slider . value , self . inc_slider . value","title":"values()"},{"location":"budgets/#fixedbudgetbox","text":"This option is for situations where a user knows exactly how much money they have to spend and want to know the optimal set of barriers to replace for that amount of money. OptiPass is run twice -- once to determine the current passabilities, and once to compute the benefit from the specified budget. The widget simply displays a box where the user enters the dollar amount for their budget. Source code in src/tidegates/budgets.py 122 123 124 125 def __init__ ( self ): super ( FixedBudgetBox , self ) . __init__ ( margin = ( 15 , 0 , 15 , 5 )) self . input = pn . widgets . TextInput ( name = 'Budget Amount' , value = '$' ) self . append ( self . input )","title":"FixedBudgetBox"},{"location":"budgets/#src.tidegates.budgets.FixedBudgetBox.parse_dollar_amount","text":"Make sure the string entered by the user has an acceptable format. It can be all digits (e.g. \"1500000\"), or digits separated by commas (e.g. \"1,500,000\"), or a number followed by a K or M (e.g. \"1.5M\"). There can be a dollar sign at the front of the string. Parameters: s ( str ) \u2013 the string entered into the text box Returns: \u2013 the value of the string converted into an integer src/tidegates/budgets.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def parse_dollar_amount ( self , s : str ): \"\"\" Make sure the string entered by the user has an acceptable format. It can be all digits (e.g. \"1500000\"), or digits separated by commas (e.g. \"1,500,000\"), or a number followed by a K or M (e.g. \"1.5M\"). There can be a dollar sign at the front of the string. Arguments: s: the string entered into the text box Returns: the value of the string converted into an integer \"\"\" try : if s . startswith ( '$' ): s = s [ 1 :] if s . endswith (( 'K' , 'M' )): multiplier = 1000 if s . endswith ( 'K' ) else 1000000 res = int ( float ( s [: - 1 ]) * multiplier ) elif ',' in s : parts = s . split ( ',' ) assert len ( parts [ 0 ]) <= 3 and ( len ( parts ) == 1 or all ( len ( p ) == 3 for p in parts [ 1 :])) res = int ( '' . join ( parts )) else : res = int ( s ) return res except Exception : raise ValueError ( 'unexpected format in dollar amount' )","title":"parse_dollar_amount()"},{"location":"budgets/#src.tidegates.budgets.FixedBudgetBox.values","text":"Return the specified budget amount as both the maximum budget and the budget interval. src/tidegates/budgets.py 130 131 132 133 134 135 136 137 138 139 def values ( self ): \"\"\" Return the specified budget amount as both the maximum budget and the budget interval. \"\"\" s = self . input . value if s . startswith ( '$' ): s = s [ 1 :] n = self . parse_dollar_amount ( self . input . value ) return n , n","title":"values()"},{"location":"data/","text":"Tidegate Data Files All of the data used by the optimizer is in a single CSV file. The file can have data on tide gates, culverts, or any obstacle encountered by migrating fish. We'll use the generic term \"barrier.\" A data file has one line for each barrier. The attributes (columns) define a barrier's ID, the ID of it's downstream neighbor, it's geographic name (typically a river system), and the costs and benefits of restoring the barrier. The web app looks for data files in the static directory. The repo has one data file, named test_wb.csv created using the example river system shown in the OptiPass user manual: BARID,REGION,DSID,HAB1,PRE1,POST1,HAB2,PRE2,POST2,COST A,OPM,NA,2.1,0.4,1.0,1.68,0.6,1.0,250 B,OPM,A,0.9,0.0,1.0,0.72,0.0,1.0,120 C,OPM,B,4.3,0.3,1.0,3.44,0.45,1.0,70 D,OPM,A,1.7,0.5,NA,1.36,0.75,NA,NA E,OPM,D,1.2,0.2,1.0,0.96,0.3,1.0,100 F,OPM,D,0.5,0.1,1.0,0.40,0.15,1.0,50 (the \"OPM\" in the REGION column stands for \"OptiPass Manual\"). The Python code for the web app refers to another data file, named workbook.csv , that is also expected to be in the static folder. This file has data from over 1,000 tide gates on the Oregon coast. It is not include in the repo. Eventually the names and locations of data files will be defined in a configuration file, and all the references to these two CSV files will be replaced with values taken from the configuration file.","title":"Data"},{"location":"data/#tidegate-data-files","text":"All of the data used by the optimizer is in a single CSV file. The file can have data on tide gates, culverts, or any obstacle encountered by migrating fish. We'll use the generic term \"barrier.\" A data file has one line for each barrier. The attributes (columns) define a barrier's ID, the ID of it's downstream neighbor, it's geographic name (typically a river system), and the costs and benefits of restoring the barrier. The web app looks for data files in the static directory. The repo has one data file, named test_wb.csv created using the example river system shown in the OptiPass user manual: BARID,REGION,DSID,HAB1,PRE1,POST1,HAB2,PRE2,POST2,COST A,OPM,NA,2.1,0.4,1.0,1.68,0.6,1.0,250 B,OPM,A,0.9,0.0,1.0,0.72,0.0,1.0,120 C,OPM,B,4.3,0.3,1.0,3.44,0.45,1.0,70 D,OPM,A,1.7,0.5,NA,1.36,0.75,NA,NA E,OPM,D,1.2,0.2,1.0,0.96,0.3,1.0,100 F,OPM,D,0.5,0.1,1.0,0.40,0.15,1.0,50 (the \"OPM\" in the REGION column stands for \"OptiPass Manual\"). The Python code for the web app refers to another data file, named workbook.csv , that is also expected to be in the static folder. This file has data from over 1,000 tide gates on the Oregon coast. It is not include in the repo. Eventually the names and locations of data files will be defined in a configuration file, and all the references to these two CSV files will be replaced with values taken from the configuration file.","title":"Tidegate Data Files"},{"location":"downloadpane/","text":"DownloadPane After OptiPass has completed the last optimization run the GUI creates an instance of this class and saves it in the Download tab of the top level display. Check the output panel to see which plots were created and to enable the net benefit plot if there is one. The pane also has a form to allow the user to enter the name of the download file, the format for the figures, and a button to click when they are ready to download the data. Parameters: outputs \u2013 the OutputPane object containing data tables and plots Source code in src/tidegates/widgets.py 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 def __init__ ( self , outputs ): \"\"\" Display a set of checkboxes for the user to select what sort of data to include in a zip file. If the gate table is not empty enable table downloads. Check the output panel to see which plots were created and to enable the net benefit plot if there is one. The pane also has a form to allow the user to enter the name of the download file, the format for the figures, and a button to click when they are ready to download the data. Arguments: outputs: the OutputPane object containing data tables and plots \"\"\" super ( DownloadPane , self ) . __init__ () self . outputs = outputs self . folder_name = self . _make_folder_name () self . grid = pn . GridBox ( ncols = 2 ) self . boxes = { } for x in [ self . NB , self . BS , self . IT , self . BD ]: b = pn . widgets . Checkbox ( name = x , styles = box_styles , stylesheets = [ box_style_sheet ]) if x in [ self . NB , self . IT ]: b . disabled = True b . value = False else : b . value = True self . boxes [ x ] = b self . grid . objects . append ( b ) self . filename_input = pn . widgets . TextInput ( name = '' , value = self . folder_name , ) self . image_type = pn . widgets . RadioBoxGroup ( name = 'IFF' , options = [ 'HTML' , 'PDF' , 'PNG' , 'JPEG' ], inline = True ) self . make_archive_button = pn . widgets . Button ( name = 'Create Output Folder' , stylesheets = [ button_style_sheet ]) self . make_archive_button . on_click ( self . _archive_cb ) self . append ( pn . pane . HTML ( '<h3>Save Outputs</h3>' , styles = header_styles )) if outputs . gate_count > 0 : self . append ( pn . pane . HTML ( '<b>Items to Include in the Output Folder:</b>' )), self . append ( self . grid ) self . append ( pn . Row ( pn . pane . HTML ( '<b>Image File Format:</b>' ), self . image_type , margin = ( 20 , 0 , 0 , 0 ), )) self . append ( pn . Row ( pn . pane . HTML ( '<b>Output Folder Name:</b>' ), self . filename_input , margin = ( 20 , 0 , 0 , 0 ), )) self . append ( self . make_archive_button ) self . append ( pn . pane . HTML ( '<p>placeholder</p>' , visible = False )) # if there are figures at least one of them is an individual target, so enable # that option; if there is a net benefit figure it's the first figure, enable it # if it's there if len ( outputs . op . display_figures ) > 0 : if outputs . op . display_figures [ 0 ][ 0 ] == 'Net' : self . boxes [ self . NB ] . value = True self . boxes [ self . NB ] . disabled = False self . boxes [ self . IT ] . value = True self . boxes [ self . IT ] . disabled = False _archive_cb ( e ) Function called when the user clicks the Download button. Create the output folder and compress it. When the archive is ready, display a FileDownload widget with a button that starts the download. src/tidegates/widgets.py 759 760 761 762 763 764 765 766 767 768 769 770 771 772 def _archive_cb ( self , e ): \"\"\" Function called when the user clicks the Download button. Create the output folder and compress it. When the archive is ready, display a FileDownload widget with a button that starts the download. \"\"\" if not any ([ x . value for x in self . boxes . values ()]): return self . loading = True base = self . _make_archive_dir () self . _save_files ( base ) p = make_archive ( base , 'zip' , base ) self . loading = False self [ - 1 ] = pn . widgets . FileDownload ( file = p , filename = self . filename + '.zip' , stylesheets = [ button_style_sheet ]) _make_archive_dir () Create an empty directory for the download, using the name in the form. src/tidegates/widgets.py 774 775 776 777 778 779 780 781 782 783 def _make_archive_dir ( self ): \"\"\" Create an empty directory for the download, using the name in the form. \"\"\" self . filename = self . filename_input . value_input or self . filename_input . value archive_dir = Path . cwd () / 'tmp' / self . filename if Path . exists ( archive_dir ): rmtree ( archive_dir ) Path . mkdir ( archive_dir ) return archive_dir _make_folder_name () Use the region names, target names, and budget range to create the default name of the zip file. src/tidegates/widgets.py 745 746 747 748 749 750 751 752 753 754 755 756 757 def _make_folder_name ( self ): \"\"\" Use the region names, target names, and budget range to create the default name of the zip file. \"\"\" parts = [ s [: 3 ] for s in self . outputs . op . regions ] lst = [ t . abbrev for t in self . outputs . op . targets ] if self . outputs . op . weighted : lst = [ f ' { lst [ i ] } x { self . outputs . op . weights [ i ] } ' for i in range ( len ( lst ))] parts . extend ( lst ) parts . append ( OP . format_budget_amount ( self . outputs . op . budget_max )[ 1 :]) if any ( t . infra for t in self . outputs . op . targets ): parts . append ( self . outputs . op . climate [ 0 ]) return '_' . join ( parts ) _save_files ( loc ) Write the tables and figures to the download directory. Parameters: loc \u2013 the path to the directory. src/tidegates/widgets.py 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 def _save_files ( self , loc ): \"\"\" Write the tables and figures to the download directory. Arguments: loc: the path to the directory. \"\"\" figures = self . outputs . op . display_figures if self . image_type . value == 'HTML' else self . outputs . op . download_figures for name , fig in figures : if name == 'Net' and not self . boxes [ self . NB ] . value : continue if name != 'Net' and not self . boxes [ self . IT ] . value : continue if self . image_type . value == 'HTML' : savehtml ( fig , filename = loc / f ' { name } .html' ) else : ext = self . image_type . value . lower () fn = loc / f ' { name } . { ext } ' fig . savefig ( fn , bbox_inches = 'tight' ) if self . boxes [ self . BS ] . value : df = self . outputs . budget_table . drop ([ 'gates' ], axis = 1 ) df . to_csv ( loc / 'budget_summary.csv' , index = False , float_format = lambda n : round ( n , 2 ) ) if self . boxes [ self . BD ] . value : self . outputs . gate_table . to_csv ( loc / 'barrier_details.csv' , index = False , float_format = lambda n : round ( n , 2 ) )","title":"DownloadPane"},{"location":"downloadpane/#downloadpane","text":"After OptiPass has completed the last optimization run the GUI creates an instance of this class and saves it in the Download tab of the top level display. Check the output panel to see which plots were created and to enable the net benefit plot if there is one. The pane also has a form to allow the user to enter the name of the download file, the format for the figures, and a button to click when they are ready to download the data. Parameters: outputs \u2013 the OutputPane object containing data tables and plots Source code in src/tidegates/widgets.py 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 def __init__ ( self , outputs ): \"\"\" Display a set of checkboxes for the user to select what sort of data to include in a zip file. If the gate table is not empty enable table downloads. Check the output panel to see which plots were created and to enable the net benefit plot if there is one. The pane also has a form to allow the user to enter the name of the download file, the format for the figures, and a button to click when they are ready to download the data. Arguments: outputs: the OutputPane object containing data tables and plots \"\"\" super ( DownloadPane , self ) . __init__ () self . outputs = outputs self . folder_name = self . _make_folder_name () self . grid = pn . GridBox ( ncols = 2 ) self . boxes = { } for x in [ self . NB , self . BS , self . IT , self . BD ]: b = pn . widgets . Checkbox ( name = x , styles = box_styles , stylesheets = [ box_style_sheet ]) if x in [ self . NB , self . IT ]: b . disabled = True b . value = False else : b . value = True self . boxes [ x ] = b self . grid . objects . append ( b ) self . filename_input = pn . widgets . TextInput ( name = '' , value = self . folder_name , ) self . image_type = pn . widgets . RadioBoxGroup ( name = 'IFF' , options = [ 'HTML' , 'PDF' , 'PNG' , 'JPEG' ], inline = True ) self . make_archive_button = pn . widgets . Button ( name = 'Create Output Folder' , stylesheets = [ button_style_sheet ]) self . make_archive_button . on_click ( self . _archive_cb ) self . append ( pn . pane . HTML ( '<h3>Save Outputs</h3>' , styles = header_styles )) if outputs . gate_count > 0 : self . append ( pn . pane . HTML ( '<b>Items to Include in the Output Folder:</b>' )), self . append ( self . grid ) self . append ( pn . Row ( pn . pane . HTML ( '<b>Image File Format:</b>' ), self . image_type , margin = ( 20 , 0 , 0 , 0 ), )) self . append ( pn . Row ( pn . pane . HTML ( '<b>Output Folder Name:</b>' ), self . filename_input , margin = ( 20 , 0 , 0 , 0 ), )) self . append ( self . make_archive_button ) self . append ( pn . pane . HTML ( '<p>placeholder</p>' , visible = False )) # if there are figures at least one of them is an individual target, so enable # that option; if there is a net benefit figure it's the first figure, enable it # if it's there if len ( outputs . op . display_figures ) > 0 : if outputs . op . display_figures [ 0 ][ 0 ] == 'Net' : self . boxes [ self . NB ] . value = True self . boxes [ self . NB ] . disabled = False self . boxes [ self . IT ] . value = True self . boxes [ self . IT ] . disabled = False","title":"DownloadPane"},{"location":"downloadpane/#src.tidegates.widgets.DownloadPane._archive_cb","text":"Function called when the user clicks the Download button. Create the output folder and compress it. When the archive is ready, display a FileDownload widget with a button that starts the download. src/tidegates/widgets.py 759 760 761 762 763 764 765 766 767 768 769 770 771 772 def _archive_cb ( self , e ): \"\"\" Function called when the user clicks the Download button. Create the output folder and compress it. When the archive is ready, display a FileDownload widget with a button that starts the download. \"\"\" if not any ([ x . value for x in self . boxes . values ()]): return self . loading = True base = self . _make_archive_dir () self . _save_files ( base ) p = make_archive ( base , 'zip' , base ) self . loading = False self [ - 1 ] = pn . widgets . FileDownload ( file = p , filename = self . filename + '.zip' , stylesheets = [ button_style_sheet ])","title":"_archive_cb()"},{"location":"downloadpane/#src.tidegates.widgets.DownloadPane._make_archive_dir","text":"Create an empty directory for the download, using the name in the form. src/tidegates/widgets.py 774 775 776 777 778 779 780 781 782 783 def _make_archive_dir ( self ): \"\"\" Create an empty directory for the download, using the name in the form. \"\"\" self . filename = self . filename_input . value_input or self . filename_input . value archive_dir = Path . cwd () / 'tmp' / self . filename if Path . exists ( archive_dir ): rmtree ( archive_dir ) Path . mkdir ( archive_dir ) return archive_dir","title":"_make_archive_dir()"},{"location":"downloadpane/#src.tidegates.widgets.DownloadPane._make_folder_name","text":"Use the region names, target names, and budget range to create the default name of the zip file. src/tidegates/widgets.py 745 746 747 748 749 750 751 752 753 754 755 756 757 def _make_folder_name ( self ): \"\"\" Use the region names, target names, and budget range to create the default name of the zip file. \"\"\" parts = [ s [: 3 ] for s in self . outputs . op . regions ] lst = [ t . abbrev for t in self . outputs . op . targets ] if self . outputs . op . weighted : lst = [ f ' { lst [ i ] } x { self . outputs . op . weights [ i ] } ' for i in range ( len ( lst ))] parts . extend ( lst ) parts . append ( OP . format_budget_amount ( self . outputs . op . budget_max )[ 1 :]) if any ( t . infra for t in self . outputs . op . targets ): parts . append ( self . outputs . op . climate [ 0 ]) return '_' . join ( parts )","title":"_make_folder_name()"},{"location":"downloadpane/#src.tidegates.widgets.DownloadPane._save_files","text":"Write the tables and figures to the download directory. Parameters: loc \u2013 the path to the directory. src/tidegates/widgets.py 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 def _save_files ( self , loc ): \"\"\" Write the tables and figures to the download directory. Arguments: loc: the path to the directory. \"\"\" figures = self . outputs . op . display_figures if self . image_type . value == 'HTML' else self . outputs . op . download_figures for name , fig in figures : if name == 'Net' and not self . boxes [ self . NB ] . value : continue if name != 'Net' and not self . boxes [ self . IT ] . value : continue if self . image_type . value == 'HTML' : savehtml ( fig , filename = loc / f ' { name } .html' ) else : ext = self . image_type . value . lower () fn = loc / f ' { name } . { ext } ' fig . savefig ( fn , bbox_inches = 'tight' ) if self . boxes [ self . BS ] . value : df = self . outputs . budget_table . drop ([ 'gates' ], axis = 1 ) df . to_csv ( loc / 'budget_summary.csv' , index = False , float_format = lambda n : round ( n , 2 ) ) if self . boxes [ self . BD ] . value : self . outputs . gate_table . to_csv ( loc / 'barrier_details.csv' , index = False , float_format = lambda n : round ( n , 2 ) )","title":"_save_files()"},{"location":"infobox/","text":"InfoBox When the user clicks the Run Optimizer button in the Start panel the GUI displays a message by calling one of the methods in this class. Messages are displayed in the modal dialog area defined by the GUI template. Parameters: template \u2013 the application template (which contains the modal dialog area to use) run_cb \u2013 a callback function to invoke after the user reviews settings and clicks \"Continue\" Source code in src/tidegates/widgets.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 def __init__ ( self , template , run_cb ): \"\"\" Initialize the module. Arguments: template: the application template (which contains the modal dialog area to use) run_cb: a callback function to invoke after the user reviews settings and clicks \"Continue\" \"\"\" super ( InfoBox , self ) . __init__ () self . template = template self . continue_button = pn . widgets . Button ( name = 'Continue' ) self . continue_button . on_click ( run_cb ) self . cancel_button = pn . widgets . Button ( name = 'Cancel' ) self . cancel_button . on_click ( self . _cancel_cb ) show_fail ( reason ) Method called if OptiPass failed. Parameters: reason \u2013 string containing the error message src/tidegates/widgets.py 433 434 435 436 437 438 439 440 441 442 443 444 445 def show_fail ( self , reason ): \"\"\" Method called if OptiPass failed. Arguments: reason: string containing the error message \"\"\" self . clear () text = self . fail_text . format ( reason ) if str ( reason ) == 'No solution' : text += ' \\n * try increasing the maximum budget' self . append ( pn . pane . Alert ( text , alert_type = 'danger' )) self . template . open_modal () show_invalid_weights ( w ) Method called when weighted targets are being used and one of the text boxes does not have a valid entry (must be a number between 1 and 5). Parameters: w ( list [ str ] ) \u2013 the list of strings read from the text entry widgets src/tidegates/widgets.py 379 380 381 382 383 384 385 386 387 388 389 390 def show_invalid_weights ( self , w : list [ str ]): \"\"\" Method called when weighted targets are being used and one of the text boxes does not have a valid entry (must be a number between 1 and 5). Arguments: w: the list of strings read from the text entry widgets \"\"\" text = self . invalid_weights_text . format ( w ) self . clear () self . append ( pn . pane . Alert ( text , alert_type = 'warning' )) self . template . open_modal () show_missing ( rlist , bmax , tlist ) Method called by the OP class when it detects missing parameters (e.g. if the user did not select a region or a target). src/tidegates/widgets.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def show_missing ( self , rlist , bmax , tlist ): \"\"\" Method called by the OP class when it detects missing parameters (e.g. if the user did not select a region or a target). \"\"\" text = self . missing_params_text if len ( rlist ) == 0 : text += ' * one or more geographic regions \\n ' if bmax == 0 : text += ' * a maximum budget \\n ' if len ( tlist ) == 0 : text += ' * one or more targets \\n ' self . clear () self . append ( pn . pane . Alert ( text , alert_type = 'warning' )) self . template . open_modal () show_params ( regions , bmax , bstep , targets , weights , climate ) Method called to allow the user to review the optimization parameters read from the various widgets. Displays each parameter and two buttons (\"Cancel\" and \"Continue\"). Parameters: regions \u2013 list of region names bmax \u2013 maximum budget amount bstep \u2013 incremwnt in budget amounts targets \u2013 list of restoration target names weights \u2013 list of target weights climate \u2013 climate scenario src/tidegates/widgets.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 def show_params ( self , regions , bmax , bstep , targets , weights , climate ): \"\"\" Method called to allow the user to review the optimization parameters read from the various widgets. Displays each parameter and two buttons (\"Cancel\" and \"Continue\"). Arguments: regions: list of region names bmax: maximum budget amount bstep: incremwnt in budget amounts targets: list of restoration target names weights: list of target weights climate: climate scenario \"\"\" n = bmax // bstep fbmax = OP . format_budget_amount ( bmax ) fbstep = OP . format_budget_amount ( bstep ) text = self . preview_message_text text += f ' * Regions: { \", \" . join ( regions ) } \\n\\n ' if n > 1 : text += f ' * { n } budget levels from { fbstep } up to { fbmax } in increments of { fbstep } \\n\\n ' else : text += f ' * a single budget of { fbmax } \\n\\n ' targets = [ t . split ( ':' )[ - 1 ] for t in targets ] if weights : targets = [ f ' { targets [ i ] } \u2a09 { weights [ i ] } ' for i in range ( len ( targets ))] text += f ' * Targets: { \", \" . join ( targets ) } \\n ' text += f ' * Climate: { climate } \\n\\n ' self . clear () self . append ( pn . pane . Alert ( text , alert_type = 'secondary' )) self . append ( pn . Row ( self . cancel_button , self . continue_button )) self . template . open_modal () show_success () Method called after OptiPass has finished running and the results have been parsed successfully. src/tidegates/widgets.py 424 425 426 427 428 429 430 431 def show_success ( self ): \"\"\" Method called after OptiPass has finished running and the results have been parsed successfully. \"\"\" self . clear () self . append ( pn . pane . Alert ( self . success_text , alert_type = 'success' )) self . template . open_modal ()","title":"InfoBox"},{"location":"infobox/#infobox","text":"When the user clicks the Run Optimizer button in the Start panel the GUI displays a message by calling one of the methods in this class. Messages are displayed in the modal dialog area defined by the GUI template. Parameters: template \u2013 the application template (which contains the modal dialog area to use) run_cb \u2013 a callback function to invoke after the user reviews settings and clicks \"Continue\" Source code in src/tidegates/widgets.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 def __init__ ( self , template , run_cb ): \"\"\" Initialize the module. Arguments: template: the application template (which contains the modal dialog area to use) run_cb: a callback function to invoke after the user reviews settings and clicks \"Continue\" \"\"\" super ( InfoBox , self ) . __init__ () self . template = template self . continue_button = pn . widgets . Button ( name = 'Continue' ) self . continue_button . on_click ( run_cb ) self . cancel_button = pn . widgets . Button ( name = 'Cancel' ) self . cancel_button . on_click ( self . _cancel_cb )","title":"InfoBox"},{"location":"infobox/#src.tidegates.widgets.InfoBox.show_fail","text":"Method called if OptiPass failed. Parameters: reason \u2013 string containing the error message src/tidegates/widgets.py 433 434 435 436 437 438 439 440 441 442 443 444 445 def show_fail ( self , reason ): \"\"\" Method called if OptiPass failed. Arguments: reason: string containing the error message \"\"\" self . clear () text = self . fail_text . format ( reason ) if str ( reason ) == 'No solution' : text += ' \\n * try increasing the maximum budget' self . append ( pn . pane . Alert ( text , alert_type = 'danger' )) self . template . open_modal ()","title":"show_fail()"},{"location":"infobox/#src.tidegates.widgets.InfoBox.show_invalid_weights","text":"Method called when weighted targets are being used and one of the text boxes does not have a valid entry (must be a number between 1 and 5). Parameters: w ( list [ str ] ) \u2013 the list of strings read from the text entry widgets src/tidegates/widgets.py 379 380 381 382 383 384 385 386 387 388 389 390 def show_invalid_weights ( self , w : list [ str ]): \"\"\" Method called when weighted targets are being used and one of the text boxes does not have a valid entry (must be a number between 1 and 5). Arguments: w: the list of strings read from the text entry widgets \"\"\" text = self . invalid_weights_text . format ( w ) self . clear () self . append ( pn . pane . Alert ( text , alert_type = 'warning' )) self . template . open_modal ()","title":"show_invalid_weights()"},{"location":"infobox/#src.tidegates.widgets.InfoBox.show_missing","text":"Method called by the OP class when it detects missing parameters (e.g. if the user did not select a region or a target). src/tidegates/widgets.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def show_missing ( self , rlist , bmax , tlist ): \"\"\" Method called by the OP class when it detects missing parameters (e.g. if the user did not select a region or a target). \"\"\" text = self . missing_params_text if len ( rlist ) == 0 : text += ' * one or more geographic regions \\n ' if bmax == 0 : text += ' * a maximum budget \\n ' if len ( tlist ) == 0 : text += ' * one or more targets \\n ' self . clear () self . append ( pn . pane . Alert ( text , alert_type = 'warning' )) self . template . open_modal ()","title":"show_missing()"},{"location":"infobox/#src.tidegates.widgets.InfoBox.show_params","text":"Method called to allow the user to review the optimization parameters read from the various widgets. Displays each parameter and two buttons (\"Cancel\" and \"Continue\"). Parameters: regions \u2013 list of region names bmax \u2013 maximum budget amount bstep \u2013 incremwnt in budget amounts targets \u2013 list of restoration target names weights \u2013 list of target weights climate \u2013 climate scenario src/tidegates/widgets.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 def show_params ( self , regions , bmax , bstep , targets , weights , climate ): \"\"\" Method called to allow the user to review the optimization parameters read from the various widgets. Displays each parameter and two buttons (\"Cancel\" and \"Continue\"). Arguments: regions: list of region names bmax: maximum budget amount bstep: incremwnt in budget amounts targets: list of restoration target names weights: list of target weights climate: climate scenario \"\"\" n = bmax // bstep fbmax = OP . format_budget_amount ( bmax ) fbstep = OP . format_budget_amount ( bstep ) text = self . preview_message_text text += f ' * Regions: { \", \" . join ( regions ) } \\n\\n ' if n > 1 : text += f ' * { n } budget levels from { fbstep } up to { fbmax } in increments of { fbstep } \\n\\n ' else : text += f ' * a single budget of { fbmax } \\n\\n ' targets = [ t . split ( ':' )[ - 1 ] for t in targets ] if weights : targets = [ f ' { targets [ i ] } \u2a09 { weights [ i ] } ' for i in range ( len ( targets ))] text += f ' * Targets: { \", \" . join ( targets ) } \\n ' text += f ' * Climate: { climate } \\n\\n ' self . clear () self . append ( pn . pane . Alert ( text , alert_type = 'secondary' )) self . append ( pn . Row ( self . cancel_button , self . continue_button )) self . template . open_modal ()","title":"show_params()"},{"location":"infobox/#src.tidegates.widgets.InfoBox.show_success","text":"Method called after OptiPass has finished running and the results have been parsed successfully. src/tidegates/widgets.py 424 425 426 427 428 429 430 431 def show_success ( self ): \"\"\" Method called after OptiPass has finished running and the results have been parsed successfully. \"\"\" self . clear () self . append ( pn . pane . Alert ( self . success_text , alert_type = 'success' )) self . template . open_modal ()","title":"show_success()"},{"location":"install/","text":"Installation The first step is to set up the execution environment. If you are installing this code on system that will run other Python applications we recommend creating and activating a new virtual environment with venv . You will need Python 3.10 or later. If you are setting up a VM dedicated to just this application you can simply install Python 3.10 or later and add the libraries to the global environment. Log in to your VM with an administrator account. Obtain a copy of the repo, either by cloning it or downloading the .zip file. Open a terminal and navigate to the directory. You should see the following structure: tidegates \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 README.md \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 bin/ \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 static/ \u251c\u2500\u2500 templates/ \u2514\u2500\u2500 tidegates/ Use PIP to install all the dependencies: > python -m pip install -r requirements.txt Move a copy of the OptiPass command line application to the bin directory. After you do this that directory should have the exe file for OptiPass and some Python scripts that are part of the repo: bin \u251c\u2500\u2500 OptiPassMain.exe \u2514\u2500\u2500 sanitize.py","title":"Install and Configure"},{"location":"install/#installation","text":"The first step is to set up the execution environment. If you are installing this code on system that will run other Python applications we recommend creating and activating a new virtual environment with venv . You will need Python 3.10 or later. If you are setting up a VM dedicated to just this application you can simply install Python 3.10 or later and add the libraries to the global environment. Log in to your VM with an administrator account. Obtain a copy of the repo, either by cloning it or downloading the .zip file. Open a terminal and navigate to the directory. You should see the following structure: tidegates \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 README.md \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 bin/ \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 static/ \u251c\u2500\u2500 templates/ \u2514\u2500\u2500 tidegates/ Use PIP to install all the dependencies: > python -m pip install -r requirements.txt Move a copy of the OptiPass command line application to the bin directory. After you do this that directory should have the exe file for OptiPass and some Python scripts that are part of the repo: bin \u251c\u2500\u2500 OptiPassMain.exe \u2514\u2500\u2500 sanitize.py","title":"Installation"},{"location":"main/","text":"Main This module has the code that sets up the application and launches the Bokeh server. init_cli Use argparse to define the command line arguments: --action : a verb that defines how the app will run: generate : used to test the code that makes the input file for OptiPass; make the file, print it, and exit run : used to test the code that runs OptiPass; make the input file, then create and run the shell commands that run OptiPass.exe preview : same as run but just prints the shell commands instead of executing them parse : used to test the code that parses the output from OptiPass; requires the --output option to specify the path to files created by OptiPass all : used to run an integration test: generates the input for OptiPass, runs OptiPass, parses the results, displays the plots gui : same as all but puts the results in the GUI --project : path to a CSV file with barrier descriptions (default: static/workbook.csv ) --regions : one or more region names (used to test data file generation and parsing) Command Line The application needs files in the bin and static folders of the project. To run the application, open a terminal window and cd to the top level folder. The application is in the src folder. Type this command to make sure the application is installed and configured: $ python3 src/main.py --help Start the Server To start the application simply run the program without any command line arguments: $ python3 src/main.py Integration Tests The command line arguments allow the developer to run various integration tests. This example tests the code that creates the input files for OptiPass by making a file for gates in the Coos region and targets CO and CH. $ python3 src/main.py --action generate --region Coos --targets CO CH --output test1 Test the code that makes the output panes (data tables and ROI plots) by parsing the results of a previous run, in this case a set of files that start with the string tmpwok9i8rl . $ python3 src/main.py --action parse --region Coquille --out tmpwok9i8rl Source Use argparse to create the command line API. Returns: \u2013 a Namespace object with values of the command line arguments. src/main.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def init_cli (): \"\"\" Use argparse to create the command line API. Returns: a Namespace object with values of the command line arguments. \"\"\" parser = argparse . ArgumentParser ( formatter_class = argparse . RawDescriptionHelpFormatter , description = desc , epilog = epi , ) # NOTE: no argument can be required -- it should be possible to run this script with no # command line arguments, which is how it's run in the Docker container when launching the # web app parser . add_argument ( '--action' , metavar = 'A' , choices = [ 'generate' , 'preview' , 'run' , 'parse' , 'all' , 'gui' ], help = 'operation to perform' ) parser . add_argument ( '--project' , metavar = 'F' , default = 'static/workbook.csv' , help = 'CSV file with barrier data' ) parser . add_argument ( '--regions' , metavar = 'R' , default = 'all' , nargs = '+' , help = 'one or more region names' ) parser . add_argument ( '--targets' , metavar = 'T' , nargs = '+' , default = [ 'CO' , 'FI' ], help = 'one or more restoration targets' ) parser . add_argument ( '--budget' , metavar = 'N' , nargs = 2 , default = [ 5000 , 1000 ], help = 'max budget, budget delta' ) parser . add_argument ( '--climate' , metavar = 'C' , choices = [ 'current' , 'future' ], default = 'current' , help = 'climate scenario' ) parser . add_argument ( '--output' , metavar = 'F' , help = 'base name of output files (optional)' ) parser . add_argument ( '--scaled' , action = 'store_true' , help = 'compute benefit using scaled amounts' ) return parser . parse_args () make_app Instantiate the top level widget. Returns: \u2013 a TideGatesApp object src/main.py 70 71 72 73 74 75 76 77 78 79 80 def make_app (): \"\"\" Instantiate the top level widget. Returns: a TideGatesApp object \"\"\" return TideGatesApp ( title = 'Tide Gate Optimization' , sidebar_width = 450 ) start_app Launch the Bokeh server. src/main.py 82 83 84 85 86 87 88 89 90 91 92 93 94 def start_app (): \"\"\" Launch the Bokeh server. \"\"\" pn . extension ( design = 'native' ) pn . serve ( { 'tidegates' : make_app }, port = 5006 , admin = True , verbose = True , autoreload = True , websocket_origin = '*' , ) validate_options Make sure values specified on the command line are valid for that option. Prints an error message and exits if an unknown value is specified. Example: check the names specified for the \"region\" option by making sure the values on the command line (\"args.region\") are in the list of valid names (\"region_names\"). validate_options('region', args.regions, region_names) Parameters: name ( str ) \u2013 the argument name given ( list [ str ] ) \u2013 the strings typed by the user on the command line expected ( list [ str ] ) \u2013 a list of acceptable values src/main.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def validate_options ( name : str , given : list [ str ], expected : list [ str ], ): \"\"\" Make sure values specified on the command line are valid for that option. Prints an error message and exits if an unknown value is specified. Example: check the names specified for the \"region\" option by making sure the values on the command line (\"args.region\") are in the list of valid names (\"region_names\"). validate_options('region', args.regions, region_names) Args: name: the argument name given: the strings typed by the user on the command line expected: a list of acceptable values \"\"\" if not all ( x in expected for x in given ): print ( f 'unknown { name } not in { expected } ' ) exit ( 1 )","title":"Main"},{"location":"main/#main","text":"This module has the code that sets up the application and launches the Bokeh server.","title":"Main"},{"location":"main/#init_cli","text":"Use argparse to define the command line arguments: --action : a verb that defines how the app will run: generate : used to test the code that makes the input file for OptiPass; make the file, print it, and exit run : used to test the code that runs OptiPass; make the input file, then create and run the shell commands that run OptiPass.exe preview : same as run but just prints the shell commands instead of executing them parse : used to test the code that parses the output from OptiPass; requires the --output option to specify the path to files created by OptiPass all : used to run an integration test: generates the input for OptiPass, runs OptiPass, parses the results, displays the plots gui : same as all but puts the results in the GUI --project : path to a CSV file with barrier descriptions (default: static/workbook.csv ) --regions : one or more region names (used to test data file generation and parsing) Command Line The application needs files in the bin and static folders of the project. To run the application, open a terminal window and cd to the top level folder. The application is in the src folder. Type this command to make sure the application is installed and configured: $ python3 src/main.py --help Start the Server To start the application simply run the program without any command line arguments: $ python3 src/main.py Integration Tests The command line arguments allow the developer to run various integration tests. This example tests the code that creates the input files for OptiPass by making a file for gates in the Coos region and targets CO and CH. $ python3 src/main.py --action generate --region Coos --targets CO CH --output test1 Test the code that makes the output panes (data tables and ROI plots) by parsing the results of a previous run, in this case a set of files that start with the string tmpwok9i8rl . $ python3 src/main.py --action parse --region Coquille --out tmpwok9i8rl Source Use argparse to create the command line API. Returns: \u2013 a Namespace object with values of the command line arguments. src/main.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def init_cli (): \"\"\" Use argparse to create the command line API. Returns: a Namespace object with values of the command line arguments. \"\"\" parser = argparse . ArgumentParser ( formatter_class = argparse . RawDescriptionHelpFormatter , description = desc , epilog = epi , ) # NOTE: no argument can be required -- it should be possible to run this script with no # command line arguments, which is how it's run in the Docker container when launching the # web app parser . add_argument ( '--action' , metavar = 'A' , choices = [ 'generate' , 'preview' , 'run' , 'parse' , 'all' , 'gui' ], help = 'operation to perform' ) parser . add_argument ( '--project' , metavar = 'F' , default = 'static/workbook.csv' , help = 'CSV file with barrier data' ) parser . add_argument ( '--regions' , metavar = 'R' , default = 'all' , nargs = '+' , help = 'one or more region names' ) parser . add_argument ( '--targets' , metavar = 'T' , nargs = '+' , default = [ 'CO' , 'FI' ], help = 'one or more restoration targets' ) parser . add_argument ( '--budget' , metavar = 'N' , nargs = 2 , default = [ 5000 , 1000 ], help = 'max budget, budget delta' ) parser . add_argument ( '--climate' , metavar = 'C' , choices = [ 'current' , 'future' ], default = 'current' , help = 'climate scenario' ) parser . add_argument ( '--output' , metavar = 'F' , help = 'base name of output files (optional)' ) parser . add_argument ( '--scaled' , action = 'store_true' , help = 'compute benefit using scaled amounts' ) return parser . parse_args ()","title":"init_cli"},{"location":"main/#make_app","text":"Instantiate the top level widget. Returns: \u2013 a TideGatesApp object src/main.py 70 71 72 73 74 75 76 77 78 79 80 def make_app (): \"\"\" Instantiate the top level widget. Returns: a TideGatesApp object \"\"\" return TideGatesApp ( title = 'Tide Gate Optimization' , sidebar_width = 450 )","title":"make_app"},{"location":"main/#start_app","text":"Launch the Bokeh server. src/main.py 82 83 84 85 86 87 88 89 90 91 92 93 94 def start_app (): \"\"\" Launch the Bokeh server. \"\"\" pn . extension ( design = 'native' ) pn . serve ( { 'tidegates' : make_app }, port = 5006 , admin = True , verbose = True , autoreload = True , websocket_origin = '*' , )","title":"start_app"},{"location":"main/#validate_options","text":"Make sure values specified on the command line are valid for that option. Prints an error message and exits if an unknown value is specified. Example: check the names specified for the \"region\" option by making sure the values on the command line (\"args.region\") are in the list of valid names (\"region_names\"). validate_options('region', args.regions, region_names) Parameters: name ( str ) \u2013 the argument name given ( list [ str ] ) \u2013 the strings typed by the user on the command line expected ( list [ str ] ) \u2013 a list of acceptable values src/main.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def validate_options ( name : str , given : list [ str ], expected : list [ str ], ): \"\"\" Make sure values specified on the command line are valid for that option. Prints an error message and exits if an unknown value is specified. Example: check the names specified for the \"region\" option by making sure the values on the command line (\"args.region\") are in the list of valid names (\"region_names\"). validate_options('region', args.regions, region_names) Args: name: the argument name given: the strings typed by the user on the command line expected: a list of acceptable values \"\"\" if not all ( x in expected for x in given ): print ( f 'unknown { name } not in { expected } ' ) exit ( 1 )","title":"validate_options"},{"location":"map/","text":"TGMap A TGMap object manages the display of a map that shows the locations of the barriers in a project. The constructor is passed a reference to Project object that has barrier definitions. Attributes: map \u2013 a Bokeh figure object, with x and y ranges defined by the locations of the barriers dots \u2013 a dictionary that maps region names to a list of circle glyphs for each barrier in a region ranges \u2013 a data frame that has the range of x and y coordinates for each region Source code in src/tidegates/widgets.py 35 36 37 def __init__ ( self , bf ): self . map , self . dots = self . _create_map ( bf ) self . ranges = self . _create_ranges ( bf ) _create_map ( bf ) Hidden method, called by the constructor to create a Bokeh figure based on the latitude and longitude of the barriers in a project. src/tidegates/widgets.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def _create_map ( self , bf ): \"\"\" Hidden method, called by the constructor to create a Bokeh figure based on the latitude and longitude of the barriers in a project. \"\"\" self . tile_provider = get_provider ( xyz . OpenStreetMap . Mapnik ) p = bk . figure ( title = 'Oregon Coast' , height = 900 , width = 400 , x_range = ( bf . map_info . x . min () * 0.997 , bf . map_info . x . max () * 1.003 ), y_range = ( bf . map_info . y . min () * 0.997 , bf . map_info . y . max () * 1.003 ), x_axis_type = 'mercator' , y_axis_type = 'mercator' , toolbar_location = 'below' , tools = [ 'pan' , 'wheel_zoom' , 'hover' , 'reset' ], tooltips = [ ( \"ID\" , \"@id\" ), ( \"Region\" , \"@region\" ), ( \"Type\" , \"@type\" ), ] ) p . add_tile ( self . tile_provider ) p . toolbar . autohide = True dots = { } for r in bf . regions : df = bf . map_info [ bf . map_info . region == r ] c = p . circle ( 'x' , 'y' , size = 5 , color = 'darkslategray' , source = df , tags = list ( df . id )) dots [ r ] = c c . visible = False self . outer_x = ( bf . map_info . x . min () * 0.997 , bf . map_info . x . max () * 1.003 ) self . outer_y = ( bf . map_info . y . min () * 0.997 , bf . map_info . y . max () * 1.003 ) return p , dots _create_ranges ( df ) Hidden method, called by the constructor to create a Pandas Dataframe containing the range of latitudes and longitudes of the barriers in a project. src/tidegates/widgets.py 79 80 81 82 83 84 85 86 87 88 89 90 91 def _create_ranges ( self , df ): \"\"\" Hidden method, called by the constructor to create a Pandas Dataframe containing the range of latitudes and longitudes of the barriers in a project. \"\"\" g = df . map_info . groupby ( 'region' ) return pd . DataFrame ({ 'x_min' : g . min () . x , 'x_max' : g . max () . x , 'y_min' : g . min () . y , 'y_max' : g . max () . y , }) display_regions ( selection ) This method is called when the user clicks the checkbox next to the name of a region. Set the visible attribute of each dot to True or False depending on whether the region it is in is selected. Parameters: selection \u2013 a list of names of regions currently selected src/tidegates/widgets.py 93 94 95 96 97 98 99 100 101 102 103 def display_regions ( self , selection ): \"\"\" This method is called when the user clicks the checkbox next to the name of a region. Set the visible attribute of each dot to True or False depending on whether the region it is in is selected. Arguments: selection: a list of names of regions currently selected \"\"\" for r , dots in self . dots . items (): dots . visible = r in selection zoom ( selection ) Update the map, setting the x and y range based on the currently selected regions. Parameters: selection \u2013 a list of names of regions currently selected src/tidegates/widgets.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def zoom ( self , selection ): \"\"\" Update the map, setting the x and y range based on the currently selected regions. Arguments: selection: a list of names of regions currently selected \"\"\" if len ( selection ) > 0 : xmin = min ([ self . ranges [ 'x_min' ][ r ] for r in selection ]) xmax = max ([ self . ranges [ 'x_max' ][ r ] for r in selection ]) ymin = min ([ self . ranges [ 'y_min' ][ r ] for r in selection ]) ymax = max ([ self . ranges [ 'y_max' ][ r ] for r in selection ]) mx = ( xmax + xmin ) / 2 my = ( ymax + ymin ) / 2 dx = max ( 5000 , xmax - xmin ) dy = max ( 5000 , ymax - ymin ) ar = self . map . height / self . map . width if dy / dx > ar : dx = dy / ar else : dy = dx * ar self . map . x_range . update ( start = mx - dx / 2 - 5000 , end = mx + dx / 2 + 5000 ) self . map . y_range . update ( start = my - dy / 2 , end = my + dy / 2 ) else : self . map . x_range . update ( start = self . outer_x [ 0 ], end = self . outer_x [ 1 ]) self . map . y_range . update ( start = self . outer_y [ 0 ], end = self . outer_y [ 1 ]) self . map . add_tile ( self . tile_provider )","title":"TGMap"},{"location":"map/#tgmap","text":"A TGMap object manages the display of a map that shows the locations of the barriers in a project. The constructor is passed a reference to Project object that has barrier definitions. Attributes: map \u2013 a Bokeh figure object, with x and y ranges defined by the locations of the barriers dots \u2013 a dictionary that maps region names to a list of circle glyphs for each barrier in a region ranges \u2013 a data frame that has the range of x and y coordinates for each region Source code in src/tidegates/widgets.py 35 36 37 def __init__ ( self , bf ): self . map , self . dots = self . _create_map ( bf ) self . ranges = self . _create_ranges ( bf )","title":"TGMap"},{"location":"map/#src.tidegates.widgets.TGMap._create_map","text":"Hidden method, called by the constructor to create a Bokeh figure based on the latitude and longitude of the barriers in a project. src/tidegates/widgets.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def _create_map ( self , bf ): \"\"\" Hidden method, called by the constructor to create a Bokeh figure based on the latitude and longitude of the barriers in a project. \"\"\" self . tile_provider = get_provider ( xyz . OpenStreetMap . Mapnik ) p = bk . figure ( title = 'Oregon Coast' , height = 900 , width = 400 , x_range = ( bf . map_info . x . min () * 0.997 , bf . map_info . x . max () * 1.003 ), y_range = ( bf . map_info . y . min () * 0.997 , bf . map_info . y . max () * 1.003 ), x_axis_type = 'mercator' , y_axis_type = 'mercator' , toolbar_location = 'below' , tools = [ 'pan' , 'wheel_zoom' , 'hover' , 'reset' ], tooltips = [ ( \"ID\" , \"@id\" ), ( \"Region\" , \"@region\" ), ( \"Type\" , \"@type\" ), ] ) p . add_tile ( self . tile_provider ) p . toolbar . autohide = True dots = { } for r in bf . regions : df = bf . map_info [ bf . map_info . region == r ] c = p . circle ( 'x' , 'y' , size = 5 , color = 'darkslategray' , source = df , tags = list ( df . id )) dots [ r ] = c c . visible = False self . outer_x = ( bf . map_info . x . min () * 0.997 , bf . map_info . x . max () * 1.003 ) self . outer_y = ( bf . map_info . y . min () * 0.997 , bf . map_info . y . max () * 1.003 ) return p , dots","title":"_create_map()"},{"location":"map/#src.tidegates.widgets.TGMap._create_ranges","text":"Hidden method, called by the constructor to create a Pandas Dataframe containing the range of latitudes and longitudes of the barriers in a project. src/tidegates/widgets.py 79 80 81 82 83 84 85 86 87 88 89 90 91 def _create_ranges ( self , df ): \"\"\" Hidden method, called by the constructor to create a Pandas Dataframe containing the range of latitudes and longitudes of the barriers in a project. \"\"\" g = df . map_info . groupby ( 'region' ) return pd . DataFrame ({ 'x_min' : g . min () . x , 'x_max' : g . max () . x , 'y_min' : g . min () . y , 'y_max' : g . max () . y , })","title":"_create_ranges()"},{"location":"map/#src.tidegates.widgets.TGMap.display_regions","text":"This method is called when the user clicks the checkbox next to the name of a region. Set the visible attribute of each dot to True or False depending on whether the region it is in is selected. Parameters: selection \u2013 a list of names of regions currently selected src/tidegates/widgets.py 93 94 95 96 97 98 99 100 101 102 103 def display_regions ( self , selection ): \"\"\" This method is called when the user clicks the checkbox next to the name of a region. Set the visible attribute of each dot to True or False depending on whether the region it is in is selected. Arguments: selection: a list of names of regions currently selected \"\"\" for r , dots in self . dots . items (): dots . visible = r in selection","title":"display_regions()"},{"location":"map/#src.tidegates.widgets.TGMap.zoom","text":"Update the map, setting the x and y range based on the currently selected regions. Parameters: selection \u2013 a list of names of regions currently selected src/tidegates/widgets.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def zoom ( self , selection ): \"\"\" Update the map, setting the x and y range based on the currently selected regions. Arguments: selection: a list of names of regions currently selected \"\"\" if len ( selection ) > 0 : xmin = min ([ self . ranges [ 'x_min' ][ r ] for r in selection ]) xmax = max ([ self . ranges [ 'x_max' ][ r ] for r in selection ]) ymin = min ([ self . ranges [ 'y_min' ][ r ] for r in selection ]) ymax = max ([ self . ranges [ 'y_max' ][ r ] for r in selection ]) mx = ( xmax + xmin ) / 2 my = ( ymax + ymin ) / 2 dx = max ( 5000 , xmax - xmin ) dy = max ( 5000 , ymax - ymin ) ar = self . map . height / self . map . width if dy / dx > ar : dx = dy / ar else : dy = dx * ar self . map . x_range . update ( start = mx - dx / 2 - 5000 , end = mx + dx / 2 + 5000 ) self . map . y_range . update ( start = my - dy / 2 , end = my + dy / 2 ) else : self . map . x_range . update ( start = self . outer_x [ 0 ], end = self . outer_x [ 1 ]) self . map . y_range . update ( start = self . outer_y [ 0 ], end = self . outer_y [ 1 ]) self . map . add_tile ( self . tile_provider )","title":"zoom()"},{"location":"modules/","text":"Modules The source code is in a folder named src . The top level application is in main.py . A directory named tidegates has modules for different sections of the GUI. src \u251c\u2500\u2500 main.py \u2514\u2500\u2500 tidegates \u251c\u2500\u2500 budgets.py \u251c\u2500\u2500 messages.py \u251c\u2500\u2500 optipass.py \u251c\u2500\u2500 project.py \u251c\u2500\u2500 styles.py \u251c\u2500\u2500 targets.py \u2514\u2500\u2500 widgets.py","title":"Modules"},{"location":"modules/#modules","text":"The source code is in a folder named src . The top level application is in main.py . A directory named tidegates has modules for different sections of the GUI. src \u251c\u2500\u2500 main.py \u2514\u2500\u2500 tidegates \u251c\u2500\u2500 budgets.py \u251c\u2500\u2500 messages.py \u251c\u2500\u2500 optipass.py \u251c\u2500\u2500 project.py \u251c\u2500\u2500 styles.py \u251c\u2500\u2500 targets.py \u2514\u2500\u2500 widgets.py","title":"Modules"},{"location":"optipass/","text":"OP Interface to OptiPass.exe (the command line version of OptiPass) An instance of the OP class encapsulates all the information related to a single optimization run. The constructor, called from the GUI, is passed the options selected by the user (budget levels, restoration targets, etc). Methods of the class set up and run an optimization based on these options: An OP object can also be instantiated by the command line API in main.py. When run on macOS or Linux it can be used to test the functions that creates the OP input file and parse the results. When run on a Windows system it can also run OptiPass. Parameters: project ( Project ) \u2013 a Project object containing barrier file regions ( list [ str ] ) \u2013 a list of region names from the barrier file targets ( list [ str ] ) \u2013 a list of 2-letter target IDs weights ( list [ str ] ) \u2013 optional list of integer weights for each target climate ( str ) \u2013 either 'Current' or 'Future' Source code in src/tidegates/optipass.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def __init__ ( self , project : Project , regions : list [ str ], targets : list [ str ], weights : list [ str ], climate : str ): ''' Instantiate a new OP object. Arguments: project: a Project object containing barrier file regions: a list of region names from the barrier file targets: a list of 2-letter target IDs weights: optional list of integer weights for each target climate: either 'Current' or 'Future' ''' self . project = project self . regions = regions if weights : self . weights = [ int ( s ) for s in weights ] self . weighted = True else : self . weights = [ 1 ] * len ( targets ) self . weighted = False self . climate = climate structs = self . project . targets [ climate ] if climate else self . project . targets self . targets = [ structs [ t ] for t in targets ] self . input_frame = None self . outputs = None generate_input_frame () Create a data frame that will be written in the format of a \"barrier file\" that will be read by OptiPass. Save the frame as the input_frame attribute of the object. src/tidegates/optipass.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def generate_input_frame ( self ): ''' Create a data frame that will be written in the format of a \"barrier file\" that will be read by OptiPass. Save the frame as the input_frame attribute of the object. ''' filtered = self . project . data [ self . project . data . REGION . isin ( self . regions )] filtered . index = list ( range ( len ( filtered ))) df = filtered [[ 'BARID' , 'REGION' ]] header = [ 'ID' , 'REG' ] df = pd . concat ([ df , pd . Series ( np . ones ( len ( filtered )), name = 'FOCUS' , dtype = int )], axis = 1 ) header . append ( 'FOCUS' ) df = pd . concat ([ df , filtered [ 'DSID' ]], axis = 1 ) header . append ( 'DSID' ) for t in self . targets : df = pd . concat ([ df , filtered [ t . habitat ]], axis = 1 ) header . append ( 'HAB_' + t . abbrev ) for t in self . targets : df = pd . concat ([ df , filtered [ t . prepass ]], axis = 1 ) header . append ( 'PRE_' + t . abbrev ) df = pd . concat ([ df , filtered [ 'NPROJ' ]], axis = 1 ) header . append ( 'NPROJ' ) df = pd . concat ([ df , pd . Series ( np . zeros ( len ( filtered )), name = 'ACTION' , dtype = int )], axis = 1 ) header . append ( 'ACTION' ) df = pd . concat ([ df , filtered [ 'COST' ]], axis = 1 ) header += [ 'COST' ] for t in self . targets : df = pd . concat ([ df , filtered [ t . postpass ]], axis = 1 ) header . append ( 'POST_' + t . abbrev ) df . columns = header self . input_frame = df return df run ( budgets , preview ) Generate and execute the shell commands that run OptiPass. If the shell environment includes a variable named WINEARCH it means the script is running on Linux, and we need to use Wine, otherwise build a command that will run on Windows. The first time OptiPass is run it will be given a budget of $0 to establish the current passage levels. It's then run once more at each level in the budgets list. Each time OptiPass is run it is passed the same input file, but it will write outputs to a separate file that includes the budget level in the file name. The list of output file names is saved in an instance variable. Parameters: budgets ( list [ int ] ) \u2013 a list of budget values (dollar amounts) preview ( bool ) \u2013 if True, print shell commands but don't execute them src/tidegates/optipass.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def run ( self , budgets : list [ int ], preview : bool ): ''' Generate and execute the shell commands that run OptiPass. If the shell environment includes a variable named WINEARCH it means the script is running on Linux, and we need to use Wine, otherwise build a command that will run on Windows. The first time OptiPass is run it will be given a budget of $0 to establish the current passage levels. It's then run once more at each level in the budgets list. Each time OptiPass is run it is passed the same input file, but it will write outputs to a separate file that includes the budget level in the file name. The list of output file names is saved in an instance variable. Arguments: budgets: a list of budget values (dollar amounts) preview: if True, print shell commands but don't execute them ''' if platform . system () == 'Windows' : app = 'bin \\\\ OptiPassMain.exe' elif platform . system () == 'Linux' and os . environ . get ( 'WINEARCH' ): app = 'wine bin/OptiPassMain.exe' else : Logging . log ( f ' { platform . system () } not configured to run WINE' ) self . outputs = None return template = app + ' -f {bf} -o {of} -b {n} ' df = self . generate_input_frame () _ , barrier_file = tempfile . mkstemp ( suffix = '.txt' , dir = './tmp' , text = True ) df . to_csv ( barrier_file , index = False , sep = ' \\t ' , lineterminator = os . linesep , na_rep = 'NA' ) self . budget_max , self . budget_delta = budgets num_budgets = self . budget_max // self . budget_delta outputs = [] root , _ = os . path . splitext ( barrier_file ) for i in range ( num_budgets + 1 ): outfile = f ' { root } _ { i + 1 } .txt' budget = self . budget_delta * i cmnd = template . format ( bf = barrier_file , of = outfile , n = budget ) if ( num_targets := len ( self . targets )) > 1 : cmnd += ' -t {} ' . format ( num_targets ) cmnd += ' -w ' + ', ' . join ([ str ( n ) for n in self . weights ]) Logging . log ( cmnd ) print ( cmnd ) if not preview : res = subprocess . run ( cmnd , shell = True , capture_output = True ) print ( res . stdout ) print ( res . stderr ) if preview or ( res . returncode == 0 ): outputs . append ( outfile ) # progress_hook() else : Logging . log ( 'OptiPass failed:' ) Logging . log ( res . stderr ) self . outputs = outputs collect_results ( scaled = False ) Parse the output files produced by OptiPass (the file names are in self.outputs) and collect the results, which are saved in two Pandas data frames. src/tidegates/optipass.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def collect_results ( self , scaled = False ): ''' Parse the output files produced by OptiPass (the file names are in self.outputs) and collect the results, which are saved in two Pandas data frames. ''' df = self . input_frame G = nx . from_pandas_edgelist ( df [ df . DSID . notnull ()], source = 'ID' , target = 'DSID' , create_using = nx . DiGraph ) for x in df [ df . DSID . isnull ()] . ID : G . add_node ( x ) self . paths = { n : self . _path_from ( n , G ) for n in G . nodes } cols = { x : [] for x in [ 'budget' , 'habitat' , 'gates' ]} for fn in self . outputs : self . _parse_op_output ( fn , cols ) self . summary = pd . DataFrame ( cols ) dct = {} for i in range ( len ( self . summary )): b = int ( self . summary . budget [ i ]) dct [ b ] = [ 1 if g in self . summary . gates [ i ] else 0 for g in self . input_frame . ID ] self . matrix = pd . DataFrame ( dct , index = self . input_frame . ID ) self . matrix [ 'count' ] = self . matrix . sum ( axis = 1 ) self . potential_habitat ( self . targets , scaled ) _path_from ( x , graph ) Return a list of nodes in the path from a barrier to a downstream barrier that has no descendants. Parameters: x \u2013 the barrier at the start of the path graph \u2013 the digraph with barrier connectivity src/tidegates/optipass.py 200 201 202 203 204 205 206 207 208 209 def _path_from ( self , x , graph ): ''' Return a list of nodes in the path from a barrier to a downstream barrier that has no descendants. Arguments: x: the barrier at the start of the path graph: the digraph with barrier connectivity ''' return [ x ] + [ child for _ , child in nx . dfs_edges ( graph , x )] _parse_op_output ( fn , dct ) Parse an output file, appending results to the lists. We need to handle two different formats, depending on whether there was one target or more than one. Parameters: fn \u2013 the name of the file to parse dct \u2013 a dictionary of column names, results are appended to lists in this dictionary src/tidegates/optipass.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def _parse_op_output ( self , fn , dct ): ''' Parse an output file, appending results to the lists. We need to handle two different formats, depending on whether there was one target or more than one. Arguments: fn: the name of the file to parse dct: a dictionary of column names, results are appended to lists in this dictionary ''' def parse_header_line ( line , tag ): tokens = line . strip () . split () if not tokens [ 0 ] . startswith ( tag ): return None return tokens [ 1 ] with open ( fn ) as f : amount = parse_header_line ( f . readline (), 'BUDGET' ) dct [ 'budget' ] . append ( float ( amount )) if parse_header_line ( f . readline (), 'STATUS' ) == 'NO_SOLN' : raise RuntimeError ( 'No solution' ) f . readline () # skip OPTGAP line = f . readline () if line . startswith ( 'PTNL' ): # dct['weights'].append([1.0]) hab = parse_header_line ( line , 'PTNL_HABITAT' ) dct [ 'habitat' ] . append ( float ( hab )) f . readline () # skip NETGAIN else : lst = [] while w := parse_header_line ( f . readline (), 'TARGET' ): lst . append ( float ( w )) # dct['weights'].append(lst) while line := f . readline (): # skip the individual habitat lines if line . startswith ( 'WT_PTNL_HAB' ): break hab = parse_header_line ( line , 'WT_PTNL_HAB' ) dct [ 'habitat' ] . append ( float ( hab )) f . readline () # skip WT_NETGAIN f . readline () # skip blank line f . readline () # skip header lst = [] while line := f . readline (): name , action = line . strip () . split () if action == '1' : lst . append ( name ) dct [ 'gates' ] . append ( lst ) potential_habitat ( tlist , scaled ) Compute the potential habitat available before and after restoration, using the original unscaled habitat values. Parameters: tlist \u2013 list of target IDs scaled \u2013 True if we should create weighted potential habitat values src/tidegates/optipass.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def potential_habitat ( self , tlist , scaled ): ''' Compute the potential habitat available before and after restoration, using the original unscaled habitat values. Arguments: tlist: list of target IDs scaled: True if we should create weighted potential habitat values ''' filtered = self . project . data [ self . project . data . REGION . isin ( self . regions )] . fillna ( 0 ) filtered . index = filtered . BARID wph = np . zeros ( len ( self . summary )) for i in range ( len ( tlist )): t = self . targets [ i ] cp = self . _ah ( t , filtered , scaled ) wph += ( self . weights [ i ] * cp ) col = pd . DataFrame ({ t . abbrev : cp }) self . summary = pd . concat ([ self . summary , col ], axis = 1 ) if not scaled : gain = self . _gain ( t , filtered ) self . matrix = pd . concat ([ self . matrix , filtered [ t . unscaled ], gain ], axis = 1 ) # If scaled is True add the wph column so we can compare with OP values if scaled : self . summary = pd . concat ([ self . summary , pd . DataFrame ({ 'wph' : wph })], axis = 1 ) self . summary [ 'netgain' ] = self . summary . habitat - self . summary . habitat [ 0 ] return self . summary _ah ( target , data , scaled ) Compute the available habitat for a target, in the form of a vector of habitat values for each budget level; Parameters: target \u2013 a Target object (with ID and names of data columns to use) data \u2013 the barrier dataframe scaled \u2013 if True is the scaled benefit column src/tidegates/optipass.py 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def _ah ( self , target , data , scaled ): \"\"\" Compute the available habitat for a target, in the form of a vector of habitat values for each budget level; Arguments: target: a Target object (with ID and names of data columns to use) data: the barrier dataframe scaled: if True is the scaled benefit column \"\"\" budgets = self . summary . budget m = self . matrix res = np . zeros ( len ( budgets )) for i in range ( len ( res )): action = m . iloc [:, i ] pvec = data [ target . postpass ] . where ( action == 1 , data [ target . prepass ]) habitat = data [ target . habitat if scaled else target . unscaled ] res [ i ] = sum ( prod ( pvec [ x ] for x in self . paths [ b ]) * habitat [ b ] for b in m . index ) return res table_view ( test = False ) Create a table that will be displayed by the GUI src/tidegates/optipass.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 def table_view ( self , test = False ): ''' Create a table that will be displayed by the GUI ''' filtered = self . project . data [ self . project . data . REGION . isin ( self . regions )] filtered = filtered . set_index ( 'BARID' ) if test : info_cols = other_cols = { } else : info_cols = { 'REGION' : 'Region' , 'BarrierType' : 'Type' , 'DSID' : 'DSID' , 'COST' : 'Cost' , } other_cols = { 'PrimaryTG' : 'Primary' , 'DominantTG' : 'Dominant' , 'POINT_X' : 'Longitude' , 'POINT_Y' : 'Latitude' , } budget_cols = OP . format_budgets ([ c for c in self . matrix . columns if isinstance ( c , int ) and c > 0 ]) df = pd . concat ([ filtered [ info_cols . keys ()] . rename ( columns = info_cols ), self . matrix . rename ( columns = budget_cols ), filtered [ other_cols . keys ()] . rename ( columns = other_cols ), ], axis = 1 ) dct = { t . unscaled : t . short + '_hab' for t in self . targets } dct |= { f 'GAIN_ { t . abbrev } ' : t . short + '_gain' for t in self . targets } df = df . rename ( columns = dct ) del df [ 0 ] df = df [ df [ 'count' ] > 0 ] . sort_values ( by = 'count' , ascending = False ) . fillna ( '-' ) df = df . rename ( columns = { 'count' : 'Count' }) df = df . reset_index ( names = [ 'ID' ]) # df.columns = pd.MultiIndex.from_tuples(df.columns) return df make_roi_curves () Generate ROI plots based on computed benefits. src/tidegates/optipass.py 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 def make_roi_curves ( self ): \"\"\" Generate ROI plots based on computed benefits. \"\"\" figures = [] download_figures = [] climate = None subtitle = 'Region: ' if len ( self . regions ) == 1 else 'Regions: ' subtitle += ', ' . join ( self . regions ) for i , t in enumerate ( self . targets ): title = t . long if t . infra : climate = self . climate title += f ' ( { climate } Climate)' if self . weighted : title += f ' \u2a09 { int ( self . weights [ i ]) } ' f = self . bokeh_figure ( self . summary . budget , self . summary [ t . abbrev ], title , subtitle , t . label ) figures . append (( t . short , f )) f = self . pyplot_figure ( self . summary . budget , self . summary [ t . abbrev ], title , subtitle , t . label ) download_figures . append (( t . short , f )) if len ( self . targets ) > 1 : title = 'Combined Potential Benefit' if climate : title += f ' ( { climate } Climate)' f = self . bokeh_figure ( self . summary . budget , self . summary . netgain , title , subtitle , 'Weighted Net Gain' ) figures . insert ( 0 , ( 'Net' , f )) f = self . pyplot_figure ( self . summary . budget , self . summary [ t . abbrev ], title , subtitle , 'Weighted Net Gain' ) download_figures . insert ( 0 , ( 'Net' , f )) self . display_figures = figures self . download_figures = download_figures","title":"OP (OptiPass Interface)"},{"location":"optipass/#op","text":"Interface to OptiPass.exe (the command line version of OptiPass) An instance of the OP class encapsulates all the information related to a single optimization run. The constructor, called from the GUI, is passed the options selected by the user (budget levels, restoration targets, etc). Methods of the class set up and run an optimization based on these options: An OP object can also be instantiated by the command line API in main.py. When run on macOS or Linux it can be used to test the functions that creates the OP input file and parse the results. When run on a Windows system it can also run OptiPass. Parameters: project ( Project ) \u2013 a Project object containing barrier file regions ( list [ str ] ) \u2013 a list of region names from the barrier file targets ( list [ str ] ) \u2013 a list of 2-letter target IDs weights ( list [ str ] ) \u2013 optional list of integer weights for each target climate ( str ) \u2013 either 'Current' or 'Future' Source code in src/tidegates/optipass.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def __init__ ( self , project : Project , regions : list [ str ], targets : list [ str ], weights : list [ str ], climate : str ): ''' Instantiate a new OP object. Arguments: project: a Project object containing barrier file regions: a list of region names from the barrier file targets: a list of 2-letter target IDs weights: optional list of integer weights for each target climate: either 'Current' or 'Future' ''' self . project = project self . regions = regions if weights : self . weights = [ int ( s ) for s in weights ] self . weighted = True else : self . weights = [ 1 ] * len ( targets ) self . weighted = False self . climate = climate structs = self . project . targets [ climate ] if climate else self . project . targets self . targets = [ structs [ t ] for t in targets ] self . input_frame = None self . outputs = None","title":"OP"},{"location":"optipass/#src.tidegates.optipass.OP.generate_input_frame","text":"Create a data frame that will be written in the format of a \"barrier file\" that will be read by OptiPass. Save the frame as the input_frame attribute of the object. src/tidegates/optipass.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def generate_input_frame ( self ): ''' Create a data frame that will be written in the format of a \"barrier file\" that will be read by OptiPass. Save the frame as the input_frame attribute of the object. ''' filtered = self . project . data [ self . project . data . REGION . isin ( self . regions )] filtered . index = list ( range ( len ( filtered ))) df = filtered [[ 'BARID' , 'REGION' ]] header = [ 'ID' , 'REG' ] df = pd . concat ([ df , pd . Series ( np . ones ( len ( filtered )), name = 'FOCUS' , dtype = int )], axis = 1 ) header . append ( 'FOCUS' ) df = pd . concat ([ df , filtered [ 'DSID' ]], axis = 1 ) header . append ( 'DSID' ) for t in self . targets : df = pd . concat ([ df , filtered [ t . habitat ]], axis = 1 ) header . append ( 'HAB_' + t . abbrev ) for t in self . targets : df = pd . concat ([ df , filtered [ t . prepass ]], axis = 1 ) header . append ( 'PRE_' + t . abbrev ) df = pd . concat ([ df , filtered [ 'NPROJ' ]], axis = 1 ) header . append ( 'NPROJ' ) df = pd . concat ([ df , pd . Series ( np . zeros ( len ( filtered )), name = 'ACTION' , dtype = int )], axis = 1 ) header . append ( 'ACTION' ) df = pd . concat ([ df , filtered [ 'COST' ]], axis = 1 ) header += [ 'COST' ] for t in self . targets : df = pd . concat ([ df , filtered [ t . postpass ]], axis = 1 ) header . append ( 'POST_' + t . abbrev ) df . columns = header self . input_frame = df return df","title":"generate_input_frame()"},{"location":"optipass/#src.tidegates.optipass.OP.run","text":"Generate and execute the shell commands that run OptiPass. If the shell environment includes a variable named WINEARCH it means the script is running on Linux, and we need to use Wine, otherwise build a command that will run on Windows. The first time OptiPass is run it will be given a budget of $0 to establish the current passage levels. It's then run once more at each level in the budgets list. Each time OptiPass is run it is passed the same input file, but it will write outputs to a separate file that includes the budget level in the file name. The list of output file names is saved in an instance variable. Parameters: budgets ( list [ int ] ) \u2013 a list of budget values (dollar amounts) preview ( bool ) \u2013 if True, print shell commands but don't execute them src/tidegates/optipass.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def run ( self , budgets : list [ int ], preview : bool ): ''' Generate and execute the shell commands that run OptiPass. If the shell environment includes a variable named WINEARCH it means the script is running on Linux, and we need to use Wine, otherwise build a command that will run on Windows. The first time OptiPass is run it will be given a budget of $0 to establish the current passage levels. It's then run once more at each level in the budgets list. Each time OptiPass is run it is passed the same input file, but it will write outputs to a separate file that includes the budget level in the file name. The list of output file names is saved in an instance variable. Arguments: budgets: a list of budget values (dollar amounts) preview: if True, print shell commands but don't execute them ''' if platform . system () == 'Windows' : app = 'bin \\\\ OptiPassMain.exe' elif platform . system () == 'Linux' and os . environ . get ( 'WINEARCH' ): app = 'wine bin/OptiPassMain.exe' else : Logging . log ( f ' { platform . system () } not configured to run WINE' ) self . outputs = None return template = app + ' -f {bf} -o {of} -b {n} ' df = self . generate_input_frame () _ , barrier_file = tempfile . mkstemp ( suffix = '.txt' , dir = './tmp' , text = True ) df . to_csv ( barrier_file , index = False , sep = ' \\t ' , lineterminator = os . linesep , na_rep = 'NA' ) self . budget_max , self . budget_delta = budgets num_budgets = self . budget_max // self . budget_delta outputs = [] root , _ = os . path . splitext ( barrier_file ) for i in range ( num_budgets + 1 ): outfile = f ' { root } _ { i + 1 } .txt' budget = self . budget_delta * i cmnd = template . format ( bf = barrier_file , of = outfile , n = budget ) if ( num_targets := len ( self . targets )) > 1 : cmnd += ' -t {} ' . format ( num_targets ) cmnd += ' -w ' + ', ' . join ([ str ( n ) for n in self . weights ]) Logging . log ( cmnd ) print ( cmnd ) if not preview : res = subprocess . run ( cmnd , shell = True , capture_output = True ) print ( res . stdout ) print ( res . stderr ) if preview or ( res . returncode == 0 ): outputs . append ( outfile ) # progress_hook() else : Logging . log ( 'OptiPass failed:' ) Logging . log ( res . stderr ) self . outputs = outputs","title":"run()"},{"location":"optipass/#src.tidegates.optipass.OP.collect_results","text":"Parse the output files produced by OptiPass (the file names are in self.outputs) and collect the results, which are saved in two Pandas data frames. src/tidegates/optipass.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def collect_results ( self , scaled = False ): ''' Parse the output files produced by OptiPass (the file names are in self.outputs) and collect the results, which are saved in two Pandas data frames. ''' df = self . input_frame G = nx . from_pandas_edgelist ( df [ df . DSID . notnull ()], source = 'ID' , target = 'DSID' , create_using = nx . DiGraph ) for x in df [ df . DSID . isnull ()] . ID : G . add_node ( x ) self . paths = { n : self . _path_from ( n , G ) for n in G . nodes } cols = { x : [] for x in [ 'budget' , 'habitat' , 'gates' ]} for fn in self . outputs : self . _parse_op_output ( fn , cols ) self . summary = pd . DataFrame ( cols ) dct = {} for i in range ( len ( self . summary )): b = int ( self . summary . budget [ i ]) dct [ b ] = [ 1 if g in self . summary . gates [ i ] else 0 for g in self . input_frame . ID ] self . matrix = pd . DataFrame ( dct , index = self . input_frame . ID ) self . matrix [ 'count' ] = self . matrix . sum ( axis = 1 ) self . potential_habitat ( self . targets , scaled )","title":"collect_results()"},{"location":"optipass/#src.tidegates.optipass.OP._path_from","text":"Return a list of nodes in the path from a barrier to a downstream barrier that has no descendants. Parameters: x \u2013 the barrier at the start of the path graph \u2013 the digraph with barrier connectivity src/tidegates/optipass.py 200 201 202 203 204 205 206 207 208 209 def _path_from ( self , x , graph ): ''' Return a list of nodes in the path from a barrier to a downstream barrier that has no descendants. Arguments: x: the barrier at the start of the path graph: the digraph with barrier connectivity ''' return [ x ] + [ child for _ , child in nx . dfs_edges ( graph , x )]","title":"_path_from()"},{"location":"optipass/#src.tidegates.optipass.OP._parse_op_output","text":"Parse an output file, appending results to the lists. We need to handle two different formats, depending on whether there was one target or more than one. Parameters: fn \u2013 the name of the file to parse dct \u2013 a dictionary of column names, results are appended to lists in this dictionary src/tidegates/optipass.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def _parse_op_output ( self , fn , dct ): ''' Parse an output file, appending results to the lists. We need to handle two different formats, depending on whether there was one target or more than one. Arguments: fn: the name of the file to parse dct: a dictionary of column names, results are appended to lists in this dictionary ''' def parse_header_line ( line , tag ): tokens = line . strip () . split () if not tokens [ 0 ] . startswith ( tag ): return None return tokens [ 1 ] with open ( fn ) as f : amount = parse_header_line ( f . readline (), 'BUDGET' ) dct [ 'budget' ] . append ( float ( amount )) if parse_header_line ( f . readline (), 'STATUS' ) == 'NO_SOLN' : raise RuntimeError ( 'No solution' ) f . readline () # skip OPTGAP line = f . readline () if line . startswith ( 'PTNL' ): # dct['weights'].append([1.0]) hab = parse_header_line ( line , 'PTNL_HABITAT' ) dct [ 'habitat' ] . append ( float ( hab )) f . readline () # skip NETGAIN else : lst = [] while w := parse_header_line ( f . readline (), 'TARGET' ): lst . append ( float ( w )) # dct['weights'].append(lst) while line := f . readline (): # skip the individual habitat lines if line . startswith ( 'WT_PTNL_HAB' ): break hab = parse_header_line ( line , 'WT_PTNL_HAB' ) dct [ 'habitat' ] . append ( float ( hab )) f . readline () # skip WT_NETGAIN f . readline () # skip blank line f . readline () # skip header lst = [] while line := f . readline (): name , action = line . strip () . split () if action == '1' : lst . append ( name ) dct [ 'gates' ] . append ( lst )","title":"_parse_op_output()"},{"location":"optipass/#src.tidegates.optipass.OP.potential_habitat","text":"Compute the potential habitat available before and after restoration, using the original unscaled habitat values. Parameters: tlist \u2013 list of target IDs scaled \u2013 True if we should create weighted potential habitat values src/tidegates/optipass.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def potential_habitat ( self , tlist , scaled ): ''' Compute the potential habitat available before and after restoration, using the original unscaled habitat values. Arguments: tlist: list of target IDs scaled: True if we should create weighted potential habitat values ''' filtered = self . project . data [ self . project . data . REGION . isin ( self . regions )] . fillna ( 0 ) filtered . index = filtered . BARID wph = np . zeros ( len ( self . summary )) for i in range ( len ( tlist )): t = self . targets [ i ] cp = self . _ah ( t , filtered , scaled ) wph += ( self . weights [ i ] * cp ) col = pd . DataFrame ({ t . abbrev : cp }) self . summary = pd . concat ([ self . summary , col ], axis = 1 ) if not scaled : gain = self . _gain ( t , filtered ) self . matrix = pd . concat ([ self . matrix , filtered [ t . unscaled ], gain ], axis = 1 ) # If scaled is True add the wph column so we can compare with OP values if scaled : self . summary = pd . concat ([ self . summary , pd . DataFrame ({ 'wph' : wph })], axis = 1 ) self . summary [ 'netgain' ] = self . summary . habitat - self . summary . habitat [ 0 ] return self . summary","title":"potential_habitat()"},{"location":"optipass/#src.tidegates.optipass.OP._ah","text":"Compute the available habitat for a target, in the form of a vector of habitat values for each budget level; Parameters: target \u2013 a Target object (with ID and names of data columns to use) data \u2013 the barrier dataframe scaled \u2013 if True is the scaled benefit column src/tidegates/optipass.py 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def _ah ( self , target , data , scaled ): \"\"\" Compute the available habitat for a target, in the form of a vector of habitat values for each budget level; Arguments: target: a Target object (with ID and names of data columns to use) data: the barrier dataframe scaled: if True is the scaled benefit column \"\"\" budgets = self . summary . budget m = self . matrix res = np . zeros ( len ( budgets )) for i in range ( len ( res )): action = m . iloc [:, i ] pvec = data [ target . postpass ] . where ( action == 1 , data [ target . prepass ]) habitat = data [ target . habitat if scaled else target . unscaled ] res [ i ] = sum ( prod ( pvec [ x ] for x in self . paths [ b ]) * habitat [ b ] for b in m . index ) return res","title":"_ah()"},{"location":"optipass/#src.tidegates.optipass.OP.table_view","text":"Create a table that will be displayed by the GUI src/tidegates/optipass.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 def table_view ( self , test = False ): ''' Create a table that will be displayed by the GUI ''' filtered = self . project . data [ self . project . data . REGION . isin ( self . regions )] filtered = filtered . set_index ( 'BARID' ) if test : info_cols = other_cols = { } else : info_cols = { 'REGION' : 'Region' , 'BarrierType' : 'Type' , 'DSID' : 'DSID' , 'COST' : 'Cost' , } other_cols = { 'PrimaryTG' : 'Primary' , 'DominantTG' : 'Dominant' , 'POINT_X' : 'Longitude' , 'POINT_Y' : 'Latitude' , } budget_cols = OP . format_budgets ([ c for c in self . matrix . columns if isinstance ( c , int ) and c > 0 ]) df = pd . concat ([ filtered [ info_cols . keys ()] . rename ( columns = info_cols ), self . matrix . rename ( columns = budget_cols ), filtered [ other_cols . keys ()] . rename ( columns = other_cols ), ], axis = 1 ) dct = { t . unscaled : t . short + '_hab' for t in self . targets } dct |= { f 'GAIN_ { t . abbrev } ' : t . short + '_gain' for t in self . targets } df = df . rename ( columns = dct ) del df [ 0 ] df = df [ df [ 'count' ] > 0 ] . sort_values ( by = 'count' , ascending = False ) . fillna ( '-' ) df = df . rename ( columns = { 'count' : 'Count' }) df = df . reset_index ( names = [ 'ID' ]) # df.columns = pd.MultiIndex.from_tuples(df.columns) return df","title":"table_view()"},{"location":"optipass/#src.tidegates.optipass.OP.make_roi_curves","text":"Generate ROI plots based on computed benefits. src/tidegates/optipass.py 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 def make_roi_curves ( self ): \"\"\" Generate ROI plots based on computed benefits. \"\"\" figures = [] download_figures = [] climate = None subtitle = 'Region: ' if len ( self . regions ) == 1 else 'Regions: ' subtitle += ', ' . join ( self . regions ) for i , t in enumerate ( self . targets ): title = t . long if t . infra : climate = self . climate title += f ' ( { climate } Climate)' if self . weighted : title += f ' \u2a09 { int ( self . weights [ i ]) } ' f = self . bokeh_figure ( self . summary . budget , self . summary [ t . abbrev ], title , subtitle , t . label ) figures . append (( t . short , f )) f = self . pyplot_figure ( self . summary . budget , self . summary [ t . abbrev ], title , subtitle , t . label ) download_figures . append (( t . short , f )) if len ( self . targets ) > 1 : title = 'Combined Potential Benefit' if climate : title += f ' ( { climate } Climate)' f = self . bokeh_figure ( self . summary . budget , self . summary . netgain , title , subtitle , 'Weighted Net Gain' ) figures . insert ( 0 , ( 'Net' , f )) f = self . pyplot_figure ( self . summary . budget , self . summary [ t . abbrev ], title , subtitle , 'Weighted Net Gain' ) download_figures . insert ( 0 , ( 'Net' , f )) self . display_figures = figures self . download_figures = download_figures","title":"make_roi_curves()"},{"location":"outputpane/","text":"OutputPane After OptiPass has completed the last optimization run the GUI creates an instance of this class and saves it in the Output tab of the top level display. The first part of the panel has a set of ROI curves (displayed in a tab widget showing one figure at a time), the second part has tables showing data about barriers included in solutions. Parameters: op \u2013 the main TideGatesApp object containing the optimization parameters bf \u2013 the Project object that has barrier data Source code in src/tidegates/widgets.py 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 def __init__ ( self , op , bf ): \"\"\" Use the optimization parameters (region names, target names, budget levels) and barrier data to format the output from OptiPass. The first part of the panel has a set of ROI curves (displayed in a tab widget showing one figure at a time), the second part has tables showing data about barriers included in solutions. Arguments: op: the main TideGatesApp object containing the optimization parameters bf: the Project object that has barrier data \"\"\" super ( OutputPane , self ) . __init__ () self . op = op self . bf = bf # self.figures = [] self . append ( pn . pane . HTML ( '<h3>Optimization Complete</h3>' , styles = header_styles )) self . append ( self . _make_title ()) if op . budget_max > op . budget_delta : self . append ( pn . pane . HTML ( '<h3>ROI Curves</h3>' )) self . append ( self . _make_figures_tab ()) self . append ( pn . pane . HTML ( '<h3>Budget Summary</h3>' )) self . gate_count = self . op . summary . gates . apply ( len ) . sum () if self . gate_count == 0 : self . append ( pn . pane . HTML ( '<i>No barriers selected -- consider increasing the budget</i>' )) else : self . append ( self . _make_budget_table ()) self . append ( pn . Accordion ( ( 'Barrier Details' , self . _make_gate_table ()), stylesheets = [ accordion_style_sheet ], )) _make_budget_table () Display a table that has one column for each budget level, showing which barriers were included in the solution for that level. Attach a callback function that is called when the user clicks on a row in the table (the callback updates the map to show gates used in a solution). src/tidegates/widgets.py 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 def _make_budget_table ( self ): \"\"\" Display a table that has one column for each budget level, showing which barriers were included in the solution for that level. Attach a callback function that is called when the user clicks on a row in the table (the callback updates the map to show gates used in a solution). \"\"\" df = self . op . summary [[ 'budget' , 'habitat' , 'gates' ]] colnames = [ 'Budget' , 'Net Gain' , 'gates' ] formatters = { 'Budget' : { 'type' : 'money' , 'symbol' : '$' , 'precision' : 0 }, 'Net Gain' : NumberFormatter ( format = '0.0' , text_align = 'center' ), } alignment = { 'Budget' : 'right' , 'Net Gain' : 'center' , } df = pd . concat ([ df , pd . Series ( self . op . summary . gates . apply ( len )) ], axis = 1 ) colnames . append ( '# Barriers' ) alignment [ '# Barriers' ] = 'center' for i , t in enumerate ( self . op . targets ): if t . abbrev in self . op . summary . columns : df = pd . concat ([ df , self . op . summary [ t . abbrev ]], axis = 1 ) col = t . short if self . op . weighted : col += f '\u2a09 { self . op . weights [ i ] } ' colnames . append ( col ) formatters [ col ] = NumberFormatter ( format = '0.0' , text_align = 'center' ) df . columns = colnames table = pn . widgets . Tabulator ( df , show_index = False , hidden_columns = [ 'gates' ], editors = { c : None for c in colnames }, text_align = alignment , header_align = { c : 'center' for c in colnames }, formatters = formatters , selectable = True , configuration = { 'columnDefaults' : { 'headerSort' : False }}, ) table . on_click ( self . budget_table_cb ) self . budget_table = df return table _make_figures_tab () Create a Tabs object with one tab for each ROI curve. src/tidegates/widgets.py 518 519 520 521 522 523 524 525 526 527 528 529 def _make_figures_tab ( self ): \"\"\" Create a Tabs object with one tab for each ROI curve. \"\"\" tabs = pn . Tabs ( tabs_location = 'left' , stylesheets = [ tab_style_sheet ], ) self . op . make_roi_curves () for p in self . op . display_figures : tabs . append ( p ) return tabs _make_gate_table () Make a table showing details about gates used in solutions. src/tidegates/widgets.py 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 def _make_gate_table ( self ): \"\"\" Make a table showing details about gates used in solutions. \"\"\" formatters = { } alignment = { } df = self . op . table_view () hidden = [ 'Count' ] for col in df . columns : if col . startswith ( '$' ) or col in [ 'Primary' , 'Dominant' ]: formatters [ col ] = { 'type' : 'tickCross' , 'crossElement' : '' } alignment [ col ] = 'center' elif col . endswith ( 'hab' ): c = col . replace ( '_hab' , '' ) formatters [ c ] = NumberFormatter ( format = '0.0' , text_align = 'center' ) # alignment[c] = 'center' elif col . endswith ( 'tude' ): formatters [ col ] = NumberFormatter ( format = '0.00' , text_align = 'center' ) # alignment[col] = 'right' elif col . endswith ( 'gain' ): hidden . append ( col ) elif col == 'Cost' : formatters [ col ] = { 'type' : 'money' , 'symbol' : '$' , 'precision' : 0 } alignment [ col ] = 'right' colnames = [ c . replace ( '_hab' , '' ) for c in df . columns ] if self . op . weighted : for i , t in enumerate ( self . op . targets ): if t . short not in colnames : # shouldn't happen, but just in case... continue j = colnames . index ( t . short ) colnames [ j ] += f '\u2a09 { self . op . weights [ i ] } ' formatters [ colnames [ j ]] = NumberFormatter ( format = '0.0' , text_align = 'center' ) df . columns = colnames table = pn . widgets . Tabulator ( df , show_index = False , frozen_columns = [ 'ID' ], hidden_columns = hidden , formatters = formatters , text_align = alignment , configuration = { 'columnDefaults' : { 'headerSort' : False }}, header_align = { c : 'center' for c in df . columns }, selectable = False , ) table . disabled = True self . gate_table = df return table _make_title () The top section of the output pane is a title showing the optimization parameters. src/tidegates/widgets.py 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def _make_title ( self ): \"\"\" The top section of the output pane is a title showing the optimization parameters. \"\"\" regions = self . op . regions targets = [ t . short for t in self . op . targets ] if self . op . weighted : targets = [ f ' { targets [ i ] } \u2a09 { self . op . weights [ i ] } ' for i in range ( len ( targets ))] bmax = self . op . budget_max binc = self . op . budget_delta if bmax > binc : title_template = '<p><b>Regions:</b> {r} ; <b>Targets:</b> {t} ; <b>Climate:</b> {c} ; <b>Budgets:</b> {min} to {max} </p>' return pn . pane . HTML ( title_template . format ( r = ', ' . join ( regions ), t = ', ' . join ( targets ), c = self . op . climate , min = OP . format_budget_amount ( binc ), max = OP . format_budget_amount ( bmax ), )) else : title_template = '<p><b>Regions:</b> {r} ; <b>Targets:</b> {t} ; <b>Climate:</b> {c} ; <b>Budget:</b> {b} ' return pn . pane . HTML ( title_template . format ( r = ', ' . join ( regions ), t = ', ' . join ( targets ), c = self . op . climate , b = OP . format_budget_amount ( bmax ), )) budget_table_cb ( e ) The callback function invoked when the user clicks a row in the budget table. Use the event to figure out which row was clicked. Hide any dots that were displayed previously, then make the dots for the selected row visible. src/tidegates/widgets.py 645 646 647 648 649 650 651 652 653 654 def budget_table_cb ( self , e ): \"\"\" The callback function invoked when the user clicks a row in the budget table. Use the event to figure out which row was clicked. Hide any dots that were displayed previously, then make the dots for the selected row visible. \"\"\" if n := self . selected_row : self . dots [ n ] . visible = False self . selected_row = e . row self . dots [ self . selected_row ] . visible = True hide_dots () Callback function invoked when users click on a region name in the start panel to hide any dots that might be on the map. src/tidegates/widgets.py 656 657 658 659 660 661 662 663 def hide_dots ( self ): \"\"\" Callback function invoked when users click on a region name in the start panel to hide any dots that might be on the map. \"\"\" if self . selected_row : self . dots [ self . selected_row ] . visible = False self . selected_row = None make_dots ( plot ) Called after the output panel is initialized, make a set of glyphs to display for each budget level. src/tidegates/widgets.py 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 def make_dots ( self , plot ): \"\"\" Called after the output panel is initialized, make a set of glyphs to display for each budget level. \"\"\" if hasattr ( self , 'budget_table' ): self . selected_row = None self . dots = [] for row in self . budget_table . itertuples (): df = self . bf . map_info [ self . bf . data . BARID . isin ( row . gates )] c = plot . circle_dot ( 'x' , 'y' , size = 12 , line_color = 'blue' , fill_color = 'white' , source = df ) # c = plot.star_dot('x', 'y', size=20, line_color='blue', fill_color='white', source=df) # c = plot.star('x', 'y', size=12, color='blue', source=df) # c = plot.hex('x', 'y', size=12, color='green', source=df) c . visible = False self . dots . append ( c )","title":"OutputPane"},{"location":"outputpane/#outputpane","text":"After OptiPass has completed the last optimization run the GUI creates an instance of this class and saves it in the Output tab of the top level display. The first part of the panel has a set of ROI curves (displayed in a tab widget showing one figure at a time), the second part has tables showing data about barriers included in solutions. Parameters: op \u2013 the main TideGatesApp object containing the optimization parameters bf \u2013 the Project object that has barrier data Source code in src/tidegates/widgets.py 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 def __init__ ( self , op , bf ): \"\"\" Use the optimization parameters (region names, target names, budget levels) and barrier data to format the output from OptiPass. The first part of the panel has a set of ROI curves (displayed in a tab widget showing one figure at a time), the second part has tables showing data about barriers included in solutions. Arguments: op: the main TideGatesApp object containing the optimization parameters bf: the Project object that has barrier data \"\"\" super ( OutputPane , self ) . __init__ () self . op = op self . bf = bf # self.figures = [] self . append ( pn . pane . HTML ( '<h3>Optimization Complete</h3>' , styles = header_styles )) self . append ( self . _make_title ()) if op . budget_max > op . budget_delta : self . append ( pn . pane . HTML ( '<h3>ROI Curves</h3>' )) self . append ( self . _make_figures_tab ()) self . append ( pn . pane . HTML ( '<h3>Budget Summary</h3>' )) self . gate_count = self . op . summary . gates . apply ( len ) . sum () if self . gate_count == 0 : self . append ( pn . pane . HTML ( '<i>No barriers selected -- consider increasing the budget</i>' )) else : self . append ( self . _make_budget_table ()) self . append ( pn . Accordion ( ( 'Barrier Details' , self . _make_gate_table ()), stylesheets = [ accordion_style_sheet ], ))","title":"OutputPane"},{"location":"outputpane/#src.tidegates.widgets.OutputPane._make_budget_table","text":"Display a table that has one column for each budget level, showing which barriers were included in the solution for that level. Attach a callback function that is called when the user clicks on a row in the table (the callback updates the map to show gates used in a solution). src/tidegates/widgets.py 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 def _make_budget_table ( self ): \"\"\" Display a table that has one column for each budget level, showing which barriers were included in the solution for that level. Attach a callback function that is called when the user clicks on a row in the table (the callback updates the map to show gates used in a solution). \"\"\" df = self . op . summary [[ 'budget' , 'habitat' , 'gates' ]] colnames = [ 'Budget' , 'Net Gain' , 'gates' ] formatters = { 'Budget' : { 'type' : 'money' , 'symbol' : '$' , 'precision' : 0 }, 'Net Gain' : NumberFormatter ( format = '0.0' , text_align = 'center' ), } alignment = { 'Budget' : 'right' , 'Net Gain' : 'center' , } df = pd . concat ([ df , pd . Series ( self . op . summary . gates . apply ( len )) ], axis = 1 ) colnames . append ( '# Barriers' ) alignment [ '# Barriers' ] = 'center' for i , t in enumerate ( self . op . targets ): if t . abbrev in self . op . summary . columns : df = pd . concat ([ df , self . op . summary [ t . abbrev ]], axis = 1 ) col = t . short if self . op . weighted : col += f '\u2a09 { self . op . weights [ i ] } ' colnames . append ( col ) formatters [ col ] = NumberFormatter ( format = '0.0' , text_align = 'center' ) df . columns = colnames table = pn . widgets . Tabulator ( df , show_index = False , hidden_columns = [ 'gates' ], editors = { c : None for c in colnames }, text_align = alignment , header_align = { c : 'center' for c in colnames }, formatters = formatters , selectable = True , configuration = { 'columnDefaults' : { 'headerSort' : False }}, ) table . on_click ( self . budget_table_cb ) self . budget_table = df return table","title":"_make_budget_table()"},{"location":"outputpane/#src.tidegates.widgets.OutputPane._make_figures_tab","text":"Create a Tabs object with one tab for each ROI curve. src/tidegates/widgets.py 518 519 520 521 522 523 524 525 526 527 528 529 def _make_figures_tab ( self ): \"\"\" Create a Tabs object with one tab for each ROI curve. \"\"\" tabs = pn . Tabs ( tabs_location = 'left' , stylesheets = [ tab_style_sheet ], ) self . op . make_roi_curves () for p in self . op . display_figures : tabs . append ( p ) return tabs","title":"_make_figures_tab()"},{"location":"outputpane/#src.tidegates.widgets.OutputPane._make_gate_table","text":"Make a table showing details about gates used in solutions. src/tidegates/widgets.py 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 def _make_gate_table ( self ): \"\"\" Make a table showing details about gates used in solutions. \"\"\" formatters = { } alignment = { } df = self . op . table_view () hidden = [ 'Count' ] for col in df . columns : if col . startswith ( '$' ) or col in [ 'Primary' , 'Dominant' ]: formatters [ col ] = { 'type' : 'tickCross' , 'crossElement' : '' } alignment [ col ] = 'center' elif col . endswith ( 'hab' ): c = col . replace ( '_hab' , '' ) formatters [ c ] = NumberFormatter ( format = '0.0' , text_align = 'center' ) # alignment[c] = 'center' elif col . endswith ( 'tude' ): formatters [ col ] = NumberFormatter ( format = '0.00' , text_align = 'center' ) # alignment[col] = 'right' elif col . endswith ( 'gain' ): hidden . append ( col ) elif col == 'Cost' : formatters [ col ] = { 'type' : 'money' , 'symbol' : '$' , 'precision' : 0 } alignment [ col ] = 'right' colnames = [ c . replace ( '_hab' , '' ) for c in df . columns ] if self . op . weighted : for i , t in enumerate ( self . op . targets ): if t . short not in colnames : # shouldn't happen, but just in case... continue j = colnames . index ( t . short ) colnames [ j ] += f '\u2a09 { self . op . weights [ i ] } ' formatters [ colnames [ j ]] = NumberFormatter ( format = '0.0' , text_align = 'center' ) df . columns = colnames table = pn . widgets . Tabulator ( df , show_index = False , frozen_columns = [ 'ID' ], hidden_columns = hidden , formatters = formatters , text_align = alignment , configuration = { 'columnDefaults' : { 'headerSort' : False }}, header_align = { c : 'center' for c in df . columns }, selectable = False , ) table . disabled = True self . gate_table = df return table","title":"_make_gate_table()"},{"location":"outputpane/#src.tidegates.widgets.OutputPane._make_title","text":"The top section of the output pane is a title showing the optimization parameters. src/tidegates/widgets.py 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def _make_title ( self ): \"\"\" The top section of the output pane is a title showing the optimization parameters. \"\"\" regions = self . op . regions targets = [ t . short for t in self . op . targets ] if self . op . weighted : targets = [ f ' { targets [ i ] } \u2a09 { self . op . weights [ i ] } ' for i in range ( len ( targets ))] bmax = self . op . budget_max binc = self . op . budget_delta if bmax > binc : title_template = '<p><b>Regions:</b> {r} ; <b>Targets:</b> {t} ; <b>Climate:</b> {c} ; <b>Budgets:</b> {min} to {max} </p>' return pn . pane . HTML ( title_template . format ( r = ', ' . join ( regions ), t = ', ' . join ( targets ), c = self . op . climate , min = OP . format_budget_amount ( binc ), max = OP . format_budget_amount ( bmax ), )) else : title_template = '<p><b>Regions:</b> {r} ; <b>Targets:</b> {t} ; <b>Climate:</b> {c} ; <b>Budget:</b> {b} ' return pn . pane . HTML ( title_template . format ( r = ', ' . join ( regions ), t = ', ' . join ( targets ), c = self . op . climate , b = OP . format_budget_amount ( bmax ), ))","title":"_make_title()"},{"location":"outputpane/#src.tidegates.widgets.OutputPane.budget_table_cb","text":"The callback function invoked when the user clicks a row in the budget table. Use the event to figure out which row was clicked. Hide any dots that were displayed previously, then make the dots for the selected row visible. src/tidegates/widgets.py 645 646 647 648 649 650 651 652 653 654 def budget_table_cb ( self , e ): \"\"\" The callback function invoked when the user clicks a row in the budget table. Use the event to figure out which row was clicked. Hide any dots that were displayed previously, then make the dots for the selected row visible. \"\"\" if n := self . selected_row : self . dots [ n ] . visible = False self . selected_row = e . row self . dots [ self . selected_row ] . visible = True","title":"budget_table_cb()"},{"location":"outputpane/#src.tidegates.widgets.OutputPane.hide_dots","text":"Callback function invoked when users click on a region name in the start panel to hide any dots that might be on the map. src/tidegates/widgets.py 656 657 658 659 660 661 662 663 def hide_dots ( self ): \"\"\" Callback function invoked when users click on a region name in the start panel to hide any dots that might be on the map. \"\"\" if self . selected_row : self . dots [ self . selected_row ] . visible = False self . selected_row = None","title":"hide_dots()"},{"location":"outputpane/#src.tidegates.widgets.OutputPane.make_dots","text":"Called after the output panel is initialized, make a set of glyphs to display for each budget level. src/tidegates/widgets.py 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 def make_dots ( self , plot ): \"\"\" Called after the output panel is initialized, make a set of glyphs to display for each budget level. \"\"\" if hasattr ( self , 'budget_table' ): self . selected_row = None self . dots = [] for row in self . budget_table . itertuples (): df = self . bf . map_info [ self . bf . data . BARID . isin ( row . gates )] c = plot . circle_dot ( 'x' , 'y' , size = 12 , line_color = 'blue' , fill_color = 'white' , source = df ) # c = plot.star_dot('x', 'y', size=20, line_color='blue', fill_color='white', source=df) # c = plot.star('x', 'y', size=12, color='blue', source=df) # c = plot.hex('x', 'y', size=12, color='green', source=df) c . visible = False self . dots . append ( c )","title":"make_dots()"},{"location":"project/","text":"Project Data The data required by the web app is stored in a single object defined by a class named Project. A Project object has all the information used by the GUI to display a set of tide gates. The constructor is passed the name of a CSV file that has a list of all the barriers and the ID of one of the data sets (currently either OPM or TNC_OR). The data in the CSV file and the target descriptions returned by the make_targets function in the targets module are used to initialize the attributes of the Project object. Attributes: data \u2013 a copy of the original data, in the form of a Pandas data frame map_info \u2013 a table containging geographical coordinates of the gates regions \u2013 a list of the unique region names in the file climates \u2013 a list of climate scenarios targets \u2013 a dictionary of restoration target attributes for each climate scenario target_map \u2013 a dictionary that associates target names with the target IDs Source code in src/tidegates/project.py 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , fn , ds ): self . data = pd . read_csv ( fn ) self . targets = make_targets ( ds ) if ds == DataSet . TNC_OR : self . map_info = self . _make_map_info () self . regions = self . _make_region_list () self . totals = self . _make_totals () self . climates = [ 'Current' , 'Future' ] dct = self . targets [ 'Current' ] self . target_map = { dct [ x ] . long : x for x in dct . keys ()} _make_map_info () Make a dataframe with attributes needed to display gates on a map. Map latitude and longitude columns in the input frame to Mercator coordinates, and copy the ID, region and barrier types so they can be displayed as tooltips. src/tidegates/project.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def _make_map_info ( self ): ''' Make a dataframe with attributes needed to display gates on a map. Map latitude and longitude columns in the input frame to Mercator coordinates, and copy the ID, region and barrier types so they can be displayed as tooltips. ''' df = self . data [[ 'BARID' , 'REGION' , 'BarrierType' ]] R = 6378137.0 map_info = pd . concat ([ df , np . radians ( self . data . POINT_X ) * R , np . log ( np . tan ( np . pi / 4 + np . radians ( self . data . POINT_Y ) / 2 )) * R ], axis = 1 ) map_info . columns = [ 'id' , 'region' , 'type' , 'x' , 'y' ] return map_info _make_region_list () Make a list of unique region names, sorted by latitude, so regions are displayed in order from north to south src/tidegates/project.py 56 57 58 59 60 61 62 63 def _make_region_list ( self ): ''' Make a list of unique region names, sorted by latitude, so regions are displayed in order from north to south ''' df = self . data [[ 'BARID' , 'REGION' , 'POINT_Y' ]] mf = df . groupby ( 'REGION' ) . mean ( numeric_only = True ) . sort_values ( by = 'POINT_Y' , ascending = False ) return list ( mf . index ) _make_totals () Compute the total cost to repair all barriers in each region src/tidegates/project.py 65 66 67 68 69 70 def _make_totals ( self ): ''' Compute the total cost to repair all barriers in each region ''' tf = self . data [[ 'BARID' , 'REGION' , 'COST' ]] . groupby ( 'REGION' ) . sum ( numeric_only = True ) return { x : tf . COST [ x ] for x in tf . index }","title":"Project Data"},{"location":"project/#project-data","text":"The data required by the web app is stored in a single object defined by a class named Project. A Project object has all the information used by the GUI to display a set of tide gates. The constructor is passed the name of a CSV file that has a list of all the barriers and the ID of one of the data sets (currently either OPM or TNC_OR). The data in the CSV file and the target descriptions returned by the make_targets function in the targets module are used to initialize the attributes of the Project object. Attributes: data \u2013 a copy of the original data, in the form of a Pandas data frame map_info \u2013 a table containging geographical coordinates of the gates regions \u2013 a list of the unique region names in the file climates \u2013 a list of climate scenarios targets \u2013 a dictionary of restoration target attributes for each climate scenario target_map \u2013 a dictionary that associates target names with the target IDs Source code in src/tidegates/project.py 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , fn , ds ): self . data = pd . read_csv ( fn ) self . targets = make_targets ( ds ) if ds == DataSet . TNC_OR : self . map_info = self . _make_map_info () self . regions = self . _make_region_list () self . totals = self . _make_totals () self . climates = [ 'Current' , 'Future' ] dct = self . targets [ 'Current' ] self . target_map = { dct [ x ] . long : x for x in dct . keys ()}","title":"Project Data"},{"location":"project/#src.tidegates.project.Project._make_map_info","text":"Make a dataframe with attributes needed to display gates on a map. Map latitude and longitude columns in the input frame to Mercator coordinates, and copy the ID, region and barrier types so they can be displayed as tooltips. src/tidegates/project.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def _make_map_info ( self ): ''' Make a dataframe with attributes needed to display gates on a map. Map latitude and longitude columns in the input frame to Mercator coordinates, and copy the ID, region and barrier types so they can be displayed as tooltips. ''' df = self . data [[ 'BARID' , 'REGION' , 'BarrierType' ]] R = 6378137.0 map_info = pd . concat ([ df , np . radians ( self . data . POINT_X ) * R , np . log ( np . tan ( np . pi / 4 + np . radians ( self . data . POINT_Y ) / 2 )) * R ], axis = 1 ) map_info . columns = [ 'id' , 'region' , 'type' , 'x' , 'y' ] return map_info","title":"_make_map_info()"},{"location":"project/#src.tidegates.project.Project._make_region_list","text":"Make a list of unique region names, sorted by latitude, so regions are displayed in order from north to south src/tidegates/project.py 56 57 58 59 60 61 62 63 def _make_region_list ( self ): ''' Make a list of unique region names, sorted by latitude, so regions are displayed in order from north to south ''' df = self . data [[ 'BARID' , 'REGION' , 'POINT_Y' ]] mf = df . groupby ( 'REGION' ) . mean ( numeric_only = True ) . sort_values ( by = 'POINT_Y' , ascending = False ) return list ( mf . index )","title":"_make_region_list()"},{"location":"project/#src.tidegates.project.Project._make_totals","text":"Compute the total cost to repair all barriers in each region src/tidegates/project.py 65 66 67 68 69 70 def _make_totals ( self ): ''' Compute the total cost to repair all barriers in each region ''' tf = self . data [[ 'BARID' , 'REGION' , 'COST' ]] . groupby ( 'REGION' ) . sum ( numeric_only = True ) return { x : tf . COST [ x ] for x in tf . index }","title":"_make_totals()"},{"location":"regionbox/","text":"RegionBox The region box displays the names of each geographic region in the data set, with a checkbox next to the name. When the user clicks on one of the checkboxes several actions are triggered: the set of selected regions is updated, the budget widget is notified so it can update the maximum budget (based on the total cost of all barriers in the current selection), and the map is updated by zooming in to a level that contains only the barriers in the selected regions. Parameters: project \u2013 the Project object that has region names map \u2013 the TGMap object that will be updated when regions are selected budget \u2013 the BudgetBox object to update when regions are selected Source code in src/tidegates/widgets.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def __init__ ( self , project , map , budget ): \"\"\" Create the grid of checkboxes and set up the callback function. Arguments: project: the Project object that has region names map: the TGMap object that will be updated when regions are selected budget: the BudgetBox object to update when regions are selected \"\"\" super ( RegionBox , self ) . __init__ ( margin = ( 10 , 0 , 10 , 5 )) self . totals = project . totals self . map = map self . budget_box = budget boxes = [] for name in project . regions : box = pn . widgets . Checkbox ( name = name , styles = box_styles , stylesheets = [ box_style_sheet ]) box . param . watch ( self . cb , [ 'value' ]) boxes . append ( box ) self . grid = pn . GridBox ( * boxes , ncols = 3 ) self . selected = set () self . external_cb = None self . append ( self . grid ) add_external_callback ( f ) Save a reference to an external function to call when a region box is clicked. Parameters: f \u2013 aditional function to call when a checkbox is clicked src/tidegates/widgets.py 200 201 202 203 204 205 206 207 def add_external_callback ( self , f ): \"\"\" Save a reference to an external function to call when a region box is clicked. Arguments: f: aditional function to call when a checkbox is clicked \"\"\" self . external_cb = f cb ( * events ) Callback function invoked when one of the checkboxes is clicked. If the new state of the checkbox is 'selected' the region is added to the set of selected regions, otherwise it is removed. After updating the set notify the map widget and any other widgets that have been registered as external callbacks. src/tidegates/widgets.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def cb ( self , * events ): \"\"\" Callback function invoked when one of the checkboxes is clicked. If the new state of the checkbox is 'selected' the region is added to the set of selected regions, otherwise it is removed. After updating the set notify the map widget and any other widgets that have been registered as external callbacks. \"\"\" for e in events : if e . type == 'changed' : r = e . obj . name if e . new : self . selected . add ( r ) else : self . selected . remove ( r ) amount = sum ( self . totals [ x ] for x in self . selected ) self . budget_box . set_budget_max ( amount ) self . map . display_regions ( self . selected ) self . map . zoom ( self . selected ) if self . external_cb : self . external_cb () selection () Return a list of the names of currently selected regions. src/tidegates/widgets.py 194 195 196 197 198 def selection ( self ) -> list [ str ]: \"\"\" Return a list of the names of currently selected regions. \"\"\" return self . selected","title":"RegionBox"},{"location":"regionbox/#regionbox","text":"The region box displays the names of each geographic region in the data set, with a checkbox next to the name. When the user clicks on one of the checkboxes several actions are triggered: the set of selected regions is updated, the budget widget is notified so it can update the maximum budget (based on the total cost of all barriers in the current selection), and the map is updated by zooming in to a level that contains only the barriers in the selected regions. Parameters: project \u2013 the Project object that has region names map \u2013 the TGMap object that will be updated when regions are selected budget \u2013 the BudgetBox object to update when regions are selected Source code in src/tidegates/widgets.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def __init__ ( self , project , map , budget ): \"\"\" Create the grid of checkboxes and set up the callback function. Arguments: project: the Project object that has region names map: the TGMap object that will be updated when regions are selected budget: the BudgetBox object to update when regions are selected \"\"\" super ( RegionBox , self ) . __init__ ( margin = ( 10 , 0 , 10 , 5 )) self . totals = project . totals self . map = map self . budget_box = budget boxes = [] for name in project . regions : box = pn . widgets . Checkbox ( name = name , styles = box_styles , stylesheets = [ box_style_sheet ]) box . param . watch ( self . cb , [ 'value' ]) boxes . append ( box ) self . grid = pn . GridBox ( * boxes , ncols = 3 ) self . selected = set () self . external_cb = None self . append ( self . grid )","title":"RegionBox"},{"location":"regionbox/#src.tidegates.widgets.RegionBox.add_external_callback","text":"Save a reference to an external function to call when a region box is clicked. Parameters: f \u2013 aditional function to call when a checkbox is clicked src/tidegates/widgets.py 200 201 202 203 204 205 206 207 def add_external_callback ( self , f ): \"\"\" Save a reference to an external function to call when a region box is clicked. Arguments: f: aditional function to call when a checkbox is clicked \"\"\" self . external_cb = f","title":"add_external_callback()"},{"location":"regionbox/#src.tidegates.widgets.RegionBox.cb","text":"Callback function invoked when one of the checkboxes is clicked. If the new state of the checkbox is 'selected' the region is added to the set of selected regions, otherwise it is removed. After updating the set notify the map widget and any other widgets that have been registered as external callbacks. src/tidegates/widgets.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def cb ( self , * events ): \"\"\" Callback function invoked when one of the checkboxes is clicked. If the new state of the checkbox is 'selected' the region is added to the set of selected regions, otherwise it is removed. After updating the set notify the map widget and any other widgets that have been registered as external callbacks. \"\"\" for e in events : if e . type == 'changed' : r = e . obj . name if e . new : self . selected . add ( r ) else : self . selected . remove ( r ) amount = sum ( self . totals [ x ] for x in self . selected ) self . budget_box . set_budget_max ( amount ) self . map . display_regions ( self . selected ) self . map . zoom ( self . selected ) if self . external_cb : self . external_cb ()","title":"cb()"},{"location":"regionbox/#src.tidegates.widgets.RegionBox.selection","text":"Return a list of the names of currently selected regions. src/tidegates/widgets.py 194 195 196 197 198 def selection ( self ) -> list [ str ]: \"\"\" Return a list of the names of currently selected regions. \"\"\" return self . selected","title":"selection()"},{"location":"server/","text":"Running the Server Bokeh Server The simplest way to run the web app is to start Bokeh server, the web framework that is part of the Panel library. Start a terminal session. If you're connecting to a VM you can log in as a regular user; you do not need to run as administrator. Go to the directory where the app is installed and type the PowerShell command that launches the server: > python .\\tidegates\\main.py You should see a warning message (explained below) and another message that Python has started a web server listening on port 5006: WARNING:bokeh.server.util:Host wildcard '*' will allow connections originating from multiple (or possibly all) hostnames or IPs. Use non-wildcard values to restrict access explicitly Launching server at http://localhost:5006 Python also opens your default web browser and loads the main page of the web app. Note: the app will not work with Explorer. Make sure your default browser is Edge, Chrome, or some other modern browser. Proxy Server If you are running the web app on a VM in the cloud the Bokeh server approach should be sufficient and you can ignore that warning message. But if you are running it on a Windows host on your own network, the Bokeh developers recommend a more secure setup, where the host runs Nginx, Apache, or some other web server and forwards connections to the tide gates app. See Deployment scenarios \u2014 Bokeh 3.3.1 Documentation for more information. Connecting to the Server To connect to the web app using a browser that runs on the same machine as the server (whether that's a VM or a Windows host) use the URL shown in the startup message: http://localhost:5006 (note that is HTTP, and not HTTPS; if your browser displays a warning ignore it and continue). To connect from a different machine you need to know the IP address of the system running the web app (if you're using Microsoft Remote Desktop the IP address of the remote system is displayed in a corner on the desktop). Then simply replace localhost with the four-part IP address, so the URL has this form: http://xxxx.xxxx.xxxx.xxxx:5006 The top level page has two links, one to an admin page you can use to monitor the performance of the web app, and one to the tidegates app itself. Click on Tidegates to connect to the web app. When connecting remotely it's possible to go straight to the web app, bypassing the top level page, if you include tidegates in the URL: http://xxxx.xxxx.xxxx.xxxx:5006/tidegates","title":"Server"},{"location":"server/#running-the-server","text":"","title":"Running the Server"},{"location":"server/#bokeh-server","text":"The simplest way to run the web app is to start Bokeh server, the web framework that is part of the Panel library. Start a terminal session. If you're connecting to a VM you can log in as a regular user; you do not need to run as administrator. Go to the directory where the app is installed and type the PowerShell command that launches the server: > python .\\tidegates\\main.py You should see a warning message (explained below) and another message that Python has started a web server listening on port 5006: WARNING:bokeh.server.util:Host wildcard '*' will allow connections originating from multiple (or possibly all) hostnames or IPs. Use non-wildcard values to restrict access explicitly Launching server at http://localhost:5006 Python also opens your default web browser and loads the main page of the web app. Note: the app will not work with Explorer. Make sure your default browser is Edge, Chrome, or some other modern browser.","title":"Bokeh Server"},{"location":"server/#proxy-server","text":"If you are running the web app on a VM in the cloud the Bokeh server approach should be sufficient and you can ignore that warning message. But if you are running it on a Windows host on your own network, the Bokeh developers recommend a more secure setup, where the host runs Nginx, Apache, or some other web server and forwards connections to the tide gates app. See Deployment scenarios \u2014 Bokeh 3.3.1 Documentation for more information.","title":"Proxy Server"},{"location":"server/#connecting-to-the-server","text":"To connect to the web app using a browser that runs on the same machine as the server (whether that's a VM or a Windows host) use the URL shown in the startup message: http://localhost:5006 (note that is HTTP, and not HTTPS; if your browser displays a warning ignore it and continue). To connect from a different machine you need to know the IP address of the system running the web app (if you're using Microsoft Remote Desktop the IP address of the remote system is displayed in a corner on the desktop). Then simply replace localhost with the four-part IP address, so the URL has this form: http://xxxx.xxxx.xxxx.xxxx:5006 The top level page has two links, one to an admin page you can use to monitor the performance of the web app, and one to the tidegates app itself. Click on Tidegates to connect to the web app. When connecting remotely it's possible to go straight to the web app, bypassing the top level page, if you include tidegates in the URL: http://xxxx.xxxx.xxxx.xxxx:5006/tidegates","title":"Connecting to the Server"},{"location":"targetbox/","text":"TargetBox The widget that displays restoration target options is an instance of a class named TargetBox , defined in widgets.py . It has a set of two tabs that display different options for specifying targets. The restoration targets are shown in a matrix with a selection widget next to each target name. The TargetBox widget has two tabs showing different types of selection widgets, either simple checkboxes (shown by a BasicTargetBox) or text entry widgets (shown by WeightedTargetBox). Source code in src/tidegates/widgets.py 285 286 287 288 289 290 291 def __init__ ( self ): super ( TargetBox , self ) . __init__ ( margin = ( 10 , 0 , 10 , 5 )) self . tabs = pn . Tabs ( ( 'Basic' , BasicTargetBox ()), ( 'Weighted' , WeightedTargetBox ()), ) self . append ( self . tabs ) selection () Get a list of IDs of selected targets from the current target widget. src/tidegates/widgets.py 293 294 295 296 297 def selection ( self ) -> list [ str ]: \"\"\" Get a list of IDs of selected targets from the current target widget. \"\"\" return self . tabs [ self . tabs . active ] . selection () weights () Get target weights from the current target widget. src/tidegates/widgets.py 299 300 301 302 303 def weights ( self ): \"\"\" Get target weights from the current target widget. \"\"\" return self . tabs [ self . tabs . active ] . weights () BasicTargetBox The BasicTargetBox widget displays a checkbox next to each target name. Source code in src/tidegates/widgets.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 def __init__ ( self ): \"\"\" Make the grid of checkboxes. The IDs and descriptions of targets are fetched by calling the make_layout function in the Target class. \"\"\" super ( BasicTargetBox , self ) . __init__ ( margin = ( 10 , 0 , 10 , 5 )) self . grid = pn . GridBox ( ncols = 2 ) self . boxes = { } for row in make_layout (): lst = [ ] for t in row : b = pn . widgets . Checkbox ( name = t , styles = box_styles , stylesheets = [ box_style_sheet ]) lst . append ( b ) self . boxes [ t ] = b self . grid . objects . extend ( lst ) self . append ( self . grid ) selection () Return a list of IDs of selected targets. src/tidegates/widgets.py 232 233 234 235 236 def selection ( self ) -> list [ str ]: \"\"\" Return a list of IDs of selected targets. \"\"\" return [ t for t in self . boxes if self . boxes [ t ] . value ] weights () There are no weights (all targets considered equally) so return an empty list. src/tidegates/widgets.py 238 239 240 241 242 def weights ( self ): \"\"\" There are no weights (all targets considered equally) so return an empty list. \"\"\" return [] WeightedTargetBox A WeightedTargetBox shows a text entry widget next to each target to allow users to enter a numeric weight for the target. Source code in src/tidegates/widgets.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def __init__ ( self ): \"\"\" Make the grid of text entry widgets. The IDs and descriptions of targets are fetched by calling the make_layout function in the Target class. \"\"\" super ( WeightedTargetBox , self ) . __init__ ( margin = ( 10 , 0 , 10 , 5 )) self . grid = pn . GridBox ( ncols = 2 ) for tnames in make_layout (): for t in tnames : w = pn . Row () w . append ( pn . widgets . TextInput ( name = '' , placeholder = '' , width = 25 , stylesheets = [ input_style_sheet ])) w . append ( t ) self . grid . objects . append ( w ) self . append ( self . grid ) selection () Return a list of IDs of selected targets. src/tidegates/widgets.py 265 266 267 268 269 def selection ( self ) -> list [ str ]: \"\"\" Return a list of IDs of selected targets. \"\"\" return [ w [ 1 ] . object for w in self . grid . objects if w [ 0 ] . value ] weights () Return the text content of each non-empty text entry box. src/tidegates/widgets.py 271 272 273 274 275 def weights ( self ) -> list [ str ]: \"\"\" Return the text content of each non-empty text entry box. \"\"\" return [ w [ 0 ] . value for w in self . grid . objects if w [ 0 ] . value ]","title":"TargetBox"},{"location":"targetbox/#targetbox","text":"The widget that displays restoration target options is an instance of a class named TargetBox , defined in widgets.py . It has a set of two tabs that display different options for specifying targets. The restoration targets are shown in a matrix with a selection widget next to each target name. The TargetBox widget has two tabs showing different types of selection widgets, either simple checkboxes (shown by a BasicTargetBox) or text entry widgets (shown by WeightedTargetBox). Source code in src/tidegates/widgets.py 285 286 287 288 289 290 291 def __init__ ( self ): super ( TargetBox , self ) . __init__ ( margin = ( 10 , 0 , 10 , 5 )) self . tabs = pn . Tabs ( ( 'Basic' , BasicTargetBox ()), ( 'Weighted' , WeightedTargetBox ()), ) self . append ( self . tabs )","title":"TargetBox"},{"location":"targetbox/#src.tidegates.widgets.TargetBox.selection","text":"Get a list of IDs of selected targets from the current target widget. src/tidegates/widgets.py 293 294 295 296 297 def selection ( self ) -> list [ str ]: \"\"\" Get a list of IDs of selected targets from the current target widget. \"\"\" return self . tabs [ self . tabs . active ] . selection ()","title":"selection()"},{"location":"targetbox/#src.tidegates.widgets.TargetBox.weights","text":"Get target weights from the current target widget. src/tidegates/widgets.py 299 300 301 302 303 def weights ( self ): \"\"\" Get target weights from the current target widget. \"\"\" return self . tabs [ self . tabs . active ] . weights ()","title":"weights()"},{"location":"targetbox/#basictargetbox","text":"The BasicTargetBox widget displays a checkbox next to each target name. Source code in src/tidegates/widgets.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 def __init__ ( self ): \"\"\" Make the grid of checkboxes. The IDs and descriptions of targets are fetched by calling the make_layout function in the Target class. \"\"\" super ( BasicTargetBox , self ) . __init__ ( margin = ( 10 , 0 , 10 , 5 )) self . grid = pn . GridBox ( ncols = 2 ) self . boxes = { } for row in make_layout (): lst = [ ] for t in row : b = pn . widgets . Checkbox ( name = t , styles = box_styles , stylesheets = [ box_style_sheet ]) lst . append ( b ) self . boxes [ t ] = b self . grid . objects . extend ( lst ) self . append ( self . grid )","title":"BasicTargetBox"},{"location":"targetbox/#src.tidegates.widgets.BasicTargetBox.selection","text":"Return a list of IDs of selected targets. src/tidegates/widgets.py 232 233 234 235 236 def selection ( self ) -> list [ str ]: \"\"\" Return a list of IDs of selected targets. \"\"\" return [ t for t in self . boxes if self . boxes [ t ] . value ]","title":"selection()"},{"location":"targetbox/#src.tidegates.widgets.BasicTargetBox.weights","text":"There are no weights (all targets considered equally) so return an empty list. src/tidegates/widgets.py 238 239 240 241 242 def weights ( self ): \"\"\" There are no weights (all targets considered equally) so return an empty list. \"\"\" return []","title":"weights()"},{"location":"targetbox/#weightedtargetbox","text":"A WeightedTargetBox shows a text entry widget next to each target to allow users to enter a numeric weight for the target. Source code in src/tidegates/widgets.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def __init__ ( self ): \"\"\" Make the grid of text entry widgets. The IDs and descriptions of targets are fetched by calling the make_layout function in the Target class. \"\"\" super ( WeightedTargetBox , self ) . __init__ ( margin = ( 10 , 0 , 10 , 5 )) self . grid = pn . GridBox ( ncols = 2 ) for tnames in make_layout (): for t in tnames : w = pn . Row () w . append ( pn . widgets . TextInput ( name = '' , placeholder = '' , width = 25 , stylesheets = [ input_style_sheet ])) w . append ( t ) self . grid . objects . append ( w ) self . append ( self . grid )","title":"WeightedTargetBox"},{"location":"targetbox/#src.tidegates.widgets.WeightedTargetBox.selection","text":"Return a list of IDs of selected targets. src/tidegates/widgets.py 265 266 267 268 269 def selection ( self ) -> list [ str ]: \"\"\" Return a list of IDs of selected targets. \"\"\" return [ w [ 1 ] . object for w in self . grid . objects if w [ 0 ] . value ]","title":"selection()"},{"location":"targetbox/#src.tidegates.widgets.WeightedTargetBox.weights","text":"Return the text content of each non-empty text entry box. src/tidegates/widgets.py 271 272 273 274 275 def weights ( self ) -> list [ str ]: \"\"\" Return the text content of each non-empty text entry box. \"\"\" return [ w [ 0 ] . value for w in self . grid . objects if w [ 0 ] . value ]","title":"weights()"},{"location":"targets/","text":"Restoration Targets To allow for cases where a river might be home to several different species, and the fact that barriers impact the passability of those species in different ways, a data file can be multiple columns to describe habitats. The example data shown above has two columns of habitat values, named \"HAB1\" and \"HAB2\". The values in those columns are river miles: the total amount of water upstream from a barrier before the next barrier or the river's source. In other cases the column might have land area upstream from a barrier, in units of acres or square miles. For each habitat the optimizer also needs to know the current passability at a barrier and the expected passability if the barrier is replaced or updated. The columns named \"PRE1\" and \"POST1\" are the pre- and post-restoration passabilities for \"HAB1\", and \"PRE2\" and \"POST2\" are the passabilites for \"HAB2\". When we run OptiPass we need to tell it which habitat column(s) to use. We can choose a single habitat by itself, or specify several habitat columns and tell the optimizer how to weight them. Target The Targets module defines a data structure called a Target that contains all the information about a habitat. There will be one Target object for each habitat. The object will have the names of the columns in the data file that have the habitat and passability values. It will also have names to use when the habitat is displayed in the GUI and used in output tables and plots. The Target type is defined using Python's namedtuple function, which is passed the name of the type to create and the attributes each object will have: Target = namedtuple('Target', ['abbrev', 'long', 'short', 'habitat', 'prepass', 'postpass', 'unscaled', 'label', 'infra']) The attributes are: abbrev is a short-letter ID for a habitat long is a string that will be displayed in the GUI short is a shorter name used in plots and output tables habitat is the column in the CSV file with the habitat value (see note below) prepass is the passability before restoration postpass is passability after restoration unscaled is the actual habitat, in miles for streams or acres for infrastructure (see note below) label is a string used to label the y-axis in ROI curves infra specifies the type of target (True for infrastructure, False for streams) This statement creates a Target object for Habitat 1 from the OptiPass Manual. Since this data is used for testing, and doesn't show up in the GUI, several of the fields are empty. Target('T1', '', 'Target 1', 'HAB1', 'PRE1', 'POST1', '', '', '') Here is an example of a target definition using columns from the Oregon Coast data. In this case we need to use the last three columns to tell the optimizer the target is not an infrastructure target: Target('CO', 'Coho Streams, 'Coho', 'sCO', 'PREPASS_CO', 'POSTPASS', 'Coho_salmon', 'Habitat Potential (miles)', False), Note: Scaled Data Both habitats in the example data are based on river miles, but the infrastructure habitats in the Oregon Coast data are based on other units. In order to run an optimization that combines habitat types the data file has an extra column for each habitat, containing a scaled value (for example, the \"sCO\" in the example above for Coho salmon refers to the scaled river miles column in that CSV file). The original unscaled values are still in the file, but are not used by the app. DataSet An enumeration named DataSet defines IDs for the two data sets that can be used by the web app: DataSet.OPM refers to data from the OptiPass manual DataSet.TNC_OR refers to data from the Oregon coast make_targets Create dictionaries that map two-letter target IDs to complete target descriptioms. The TNC data set has two dictionaries, one for each climate scenario. Parameters: ds ( DataSet ) \u2013 a data set ID Returns: dict \u2013 a dictionary ot Target objects src/tidegates/targets.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def make_targets ( ds : DataSet ) -> dict : ''' Create dictionaries that map two-letter target IDs to complete target descriptioms. The TNC data set has two dictionaries, one for each climate scenario. Args: ds: a data set ID Returns: a dictionary ot Target objects ''' if ds == DataSet . TNC_OR : current = dict ( fish_targets ) current |= current_infrastructure_targets future = dict ( fish_targets ) future |= future_infrastructure_targets return { 'Current' : current , 'Future' : future , } else : return opm_targets","title":"Target Definition"},{"location":"targets/#restoration-targets","text":"To allow for cases where a river might be home to several different species, and the fact that barriers impact the passability of those species in different ways, a data file can be multiple columns to describe habitats. The example data shown above has two columns of habitat values, named \"HAB1\" and \"HAB2\". The values in those columns are river miles: the total amount of water upstream from a barrier before the next barrier or the river's source. In other cases the column might have land area upstream from a barrier, in units of acres or square miles. For each habitat the optimizer also needs to know the current passability at a barrier and the expected passability if the barrier is replaced or updated. The columns named \"PRE1\" and \"POST1\" are the pre- and post-restoration passabilities for \"HAB1\", and \"PRE2\" and \"POST2\" are the passabilites for \"HAB2\". When we run OptiPass we need to tell it which habitat column(s) to use. We can choose a single habitat by itself, or specify several habitat columns and tell the optimizer how to weight them.","title":"Restoration Targets"},{"location":"targets/#target","text":"The Targets module defines a data structure called a Target that contains all the information about a habitat. There will be one Target object for each habitat. The object will have the names of the columns in the data file that have the habitat and passability values. It will also have names to use when the habitat is displayed in the GUI and used in output tables and plots. The Target type is defined using Python's namedtuple function, which is passed the name of the type to create and the attributes each object will have: Target = namedtuple('Target', ['abbrev', 'long', 'short', 'habitat', 'prepass', 'postpass', 'unscaled', 'label', 'infra']) The attributes are: abbrev is a short-letter ID for a habitat long is a string that will be displayed in the GUI short is a shorter name used in plots and output tables habitat is the column in the CSV file with the habitat value (see note below) prepass is the passability before restoration postpass is passability after restoration unscaled is the actual habitat, in miles for streams or acres for infrastructure (see note below) label is a string used to label the y-axis in ROI curves infra specifies the type of target (True for infrastructure, False for streams) This statement creates a Target object for Habitat 1 from the OptiPass Manual. Since this data is used for testing, and doesn't show up in the GUI, several of the fields are empty. Target('T1', '', 'Target 1', 'HAB1', 'PRE1', 'POST1', '', '', '') Here is an example of a target definition using columns from the Oregon Coast data. In this case we need to use the last three columns to tell the optimizer the target is not an infrastructure target: Target('CO', 'Coho Streams, 'Coho', 'sCO', 'PREPASS_CO', 'POSTPASS', 'Coho_salmon', 'Habitat Potential (miles)', False), Note: Scaled Data Both habitats in the example data are based on river miles, but the infrastructure habitats in the Oregon Coast data are based on other units. In order to run an optimization that combines habitat types the data file has an extra column for each habitat, containing a scaled value (for example, the \"sCO\" in the example above for Coho salmon refers to the scaled river miles column in that CSV file). The original unscaled values are still in the file, but are not used by the app. DataSet An enumeration named DataSet defines IDs for the two data sets that can be used by the web app: DataSet.OPM refers to data from the OptiPass manual DataSet.TNC_OR refers to data from the Oregon coast","title":"Target"},{"location":"targets/#make_targets","text":"Create dictionaries that map two-letter target IDs to complete target descriptioms. The TNC data set has two dictionaries, one for each climate scenario. Parameters: ds ( DataSet ) \u2013 a data set ID Returns: dict \u2013 a dictionary ot Target objects src/tidegates/targets.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def make_targets ( ds : DataSet ) -> dict : ''' Create dictionaries that map two-letter target IDs to complete target descriptioms. The TNC data set has two dictionaries, one for each climate scenario. Args: ds: a data set ID Returns: a dictionary ot Target objects ''' if ds == DataSet . TNC_OR : current = dict ( fish_targets ) current |= current_infrastructure_targets future = dict ( fish_targets ) future |= future_infrastructure_targets return { 'Current' : current , 'Future' : future , } else : return opm_targets","title":"make_targets"},{"location":"tests/","text":"Integration Tests Integration tests are implemented in the top level application ( main.py ). To perorm a test, run main with options that specify which type of test to run and where to find the data for the test. See the documentation for main.py for details and examples. Unit Tests If a module has unit tests they are included in the source file. Tests are defined at the end of the file, in a class that has a name that starts with Test . For example, project.py defines a class named Project, and at the end of the file is another class named TestProject. A test class defines a series of static methods that have names beginning with test . These methods are run in order. To run tests for a module, open a terminal window and cd to the top level folder. Then type a command that runs pytest , including the name of the module to test: $ pytest src/tidegates/project.py It's also possible to run all the tests with a single shell command: $ pytest src/tidegates/*.py TestProject Source code in src/tidegates/project.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 class TestProject : @staticmethod def test_load (): ''' Load the test data frame, expect to find 6 rows, with single letter barrier IDs ''' p = Project ( 'static/test_wb.csv' , DataSet . OPM ) assert isinstance ( p . data , pd . DataFrame ) assert len ( p . data ) == 6 assert list ( p . data . BARID ) == list ( 'ABCDEF' ) @staticmethod def test_regions (): ''' The list of region names should be sorted from north to south ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) assert len ( p . regions ) == 15 assert p . regions [ 0 ] == 'Columbia' assert p . regions [ - 1 ] == 'Coquille' @staticmethod def test_map_info (): ''' The frame with map information should have 5 columns ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) assert isinstance ( p . map_info , pd . DataFrame ) assert len ( p . map_info ) == len ( p . data ) assert list ( p . map_info . columns ) == [ 'id' , 'region' , 'type' , 'x' , 'y' ] @staticmethod def test_targets (): ''' There should be two sets of targets, each with 10 entries, and one entry for each target in the map. ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) assert len ( p . targets ) == 2 assert len ( p . targets [ 'Current' ]) == 10 assert len ( p . targets [ 'Future' ]) == 10 t = p . targets [ 'Current' ][ 'CO' ] assert t . short == 'Coho' assert t . long == 'Coho Streams' assert t . habitat == 'sCO' assert t . prepass == 'PREPASS_CO' assert t . postpass == 'POSTPASS' assert len ( p . target_map ) == 10 assert p . target_map [ 'Coho Streams' ] == 'CO' test_load () staticmethod Load the test data frame, expect to find 6 rows, with single letter barrier IDs src/tidegates/project.py 84 85 86 87 88 89 90 91 92 93 @staticmethod def test_load (): ''' Load the test data frame, expect to find 6 rows, with single letter barrier IDs ''' p = Project ( 'static/test_wb.csv' , DataSet . OPM ) assert isinstance ( p . data , pd . DataFrame ) assert len ( p . data ) == 6 assert list ( p . data . BARID ) == list ( 'ABCDEF' ) test_map_info () staticmethod The frame with map information should have 5 columns src/tidegates/project.py 105 106 107 108 109 110 111 112 113 @staticmethod def test_map_info (): ''' The frame with map information should have 5 columns ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) assert isinstance ( p . map_info , pd . DataFrame ) assert len ( p . map_info ) == len ( p . data ) assert list ( p . map_info . columns ) == [ 'id' , 'region' , 'type' , 'x' , 'y' ] test_regions () staticmethod The list of region names should be sorted from north to south src/tidegates/project.py 95 96 97 98 99 100 101 102 103 @staticmethod def test_regions (): ''' The list of region names should be sorted from north to south ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) assert len ( p . regions ) == 15 assert p . regions [ 0 ] == 'Columbia' assert p . regions [ - 1 ] == 'Coquille' test_targets () staticmethod There should be two sets of targets, each with 10 entries, and one entry for each target in the map. src/tidegates/project.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 @staticmethod def test_targets (): ''' There should be two sets of targets, each with 10 entries, and one entry for each target in the map. ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) assert len ( p . targets ) == 2 assert len ( p . targets [ 'Current' ]) == 10 assert len ( p . targets [ 'Future' ]) == 10 t = p . targets [ 'Current' ][ 'CO' ] assert t . short == 'Coho' assert t . long == 'Coho Streams' assert t . habitat == 'sCO' assert t . prepass == 'PREPASS_CO' assert t . postpass == 'POSTPASS' assert len ( p . target_map ) == 10 assert p . target_map [ 'Coho Streams' ] == 'CO' TestTargets Source code in src/tidegates/targets.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class TestTargets : @staticmethod def test_TNC_columns (): ''' Make sure the column names in the Target objects are the same as the column names in the data file ''' with open ( 'static/workbook.csv' ) as f : cols = f . readline () . strip () . split ( ',' ) targets = make_targets ( DataSet . TNC_OR ) for s in [ 'Current' , 'Future' ]: for t in targets [ s ] . values (): assert t . habitat in cols assert t . prepass in cols assert t . postpass in cols assert t . unscaled in cols @staticmethod def test_OPM_columns (): with open ( 'static/test_wb.csv' ) as f : cols = f . readline () . strip () . split ( ',' ) targets = make_targets ( DataSet . OPM ) for s in [ '1' , '2' ]: name = 'T' + s assert name in targets t = targets [ name ] assert t . habitat in cols assert t . prepass in cols assert t . postpass in cols test_TNC_columns () staticmethod Make sure the column names in the Target objects are the same as the column names in the data file src/tidegates/targets.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @staticmethod def test_TNC_columns (): ''' Make sure the column names in the Target objects are the same as the column names in the data file ''' with open ( 'static/workbook.csv' ) as f : cols = f . readline () . strip () . split ( ',' ) targets = make_targets ( DataSet . TNC_OR ) for s in [ 'Current' , 'Future' ]: for t in targets [ s ] . values (): assert t . habitat in cols assert t . prepass in cols assert t . postpass in cols assert t . unscaled in cols TestOP Source code in src/tidegates/optipass.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 class TestOP : @staticmethod def test_instantiate_object (): ''' Test the OP constructor. ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) op = OP ( p , [ 'Coos' ], [ 'CO' , 'CH' ], [ '1' , '1' ], 'Current' ) assert op . project == p assert op . regions == [ 'Coos' ] assert op . climate == 'Current' assert op . weights == [ 1 , 1 ] assert len ( op . targets ) == 2 t = op . targets [ 0 ] assert t . abbrev == 'CO' assert t . short == 'Coho' assert t . long == 'Coho Streams' @staticmethod def test_generate_frame (): ''' Test the structure of a frame that will be printed as a 'barrier file' for input to OptiPass ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) op = OP ( p , [ 'Coos' ], [ 'CO' , 'CH' ], [ '1' , '1' ], 'Current' ) op . generate_input_frame () tf = op . input_frame assert list ( tf . columns ) == [ 'ID' , 'REG' , 'FOCUS' , 'DSID' , 'HAB_CO' , 'HAB_CH' , 'PRE_CO' , 'PRE_CH' , 'NPROJ' , 'ACTION' , 'COST' , 'POST_CO' , 'POST_CH' ] # NOTE: the OPM project does not have habitat in unscaled (\"target\") units # so the calls to collect_results in these tests need to specify scaled = True @staticmethod def test_example_1 (): ''' Test the OPResults class by collecting results for Example 1 from the OptiPass User Manual. ''' op = OP ( Project ( 'static/test_wb.csv' , DataSet . OPM ), [ 'OPM' ], [ 'T1' ], [ '1' ], None ) op . input_frame = pd . read_csv ( 'static/Example_1/Example1.txt' , sep = ' \\t ' ) op . outputs = sorted ( glob ( 'static/Example_1/example_*.txt' )) op . collect_results ( scaled = True ) assert len ( op . targets ) == 1 assert op . targets [ 0 ] . abbrev == 'T1' # assert len(op.weights) == 1 and round(op.weights[0]) == 1 assert type ( op . summary ) == pd . DataFrame assert len ( op . summary ) == 6 assert round ( op . summary . budget . sum ()) == 1500 assert round ( op . summary . habitat . sum (), 2 ) == 23.30 budget_cols = [ col for col in op . matrix . columns if isinstance ( col , int )] assert budget_cols == list ( op . summary . budget ) # these comprehensions make lists of budgets where a specified gate was selected assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'A' , b ]] == [ 400 , 500 ] assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'D' , b ]] == [ ] assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'E' , b ]] == [ 100 , 300 ] assert op . paths [ 'E' ] == [ 'E' , 'D' , 'A' ] assert op . paths [ 'A' ] == [ 'A' ] @staticmethod def test_example_4 (): ''' Same as test_example_1, but using Example 4, which has two restoration targets. ''' op = OP ( Project ( 'static/test_wb.csv' , DataSet . OPM ), [ 'OPM' ], [ 'T1' , 'T2' ], [ '3' , '1' ], None ) op . input_frame = pd . read_csv ( 'static/Example_4/Example4.txt' , sep = ' \\t ' ) op . outputs = sorted ( glob ( 'static/Example_4/example_*.txt' )) op . collect_results ( scaled = True ) assert len ( op . targets ) == 2 assert op . targets [ 0 ] . abbrev == 'T1' and op . targets [ 1 ] . abbrev == 'T2' assert len ( op . weights ) == 2 and round ( sum ( op . weights )) == 4 assert type ( op . summary ) == pd . DataFrame assert len ( op . summary ) == 6 assert round ( op . summary . budget . sum ()) == 1500 assert round ( op . summary . habitat . sum (), 2 ) == 95.21 # using two targets does not change the gate selections assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'A' , b ]] == [ 400 , 500 ] assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'D' , b ]] == [ ] assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'E' , b ]] == [ 100 , 300 ] @staticmethod def test_potential_habitat_1 (): ''' Test the method that computes potential habitat, using the results genearated for Example 1 in the OptiPass manual. ''' op = OP ( Project ( 'static/test_wb.csv' , DataSet . OPM ), [ 'OPM' ], [ 'T1' ], [ '1' ], None ) op . input_frame = pd . read_csv ( 'static/Example_1/Example1.txt' , sep = ' \\t ' ) op . outputs = sorted ( glob ( 'static/Example_1/example_*.txt' )) op . collect_results ( scaled = True ) m = op . summary assert len ( m ) == 6 assert 'T1' in m . columns and 'wph' in m . columns assert round ( m . wph [ 0 ], 3 ) == 1.238 assert round ( m . wph [ 5 ], 3 ) == 8.520 @staticmethod def test_potential_habitat_4 (): ''' Same as test_potential_habitat_1, but using Example 4, with two restoration targets ''' op = OP ( Project ( 'static/test_wb.csv' , DataSet . OPM ), [ 'OPM' ], [ 'T1' , 'T2' ], [ '3' , '1' ], None ) op . input_frame = pd . read_csv ( 'static/Example_4/Example4.txt' , sep = ' \\t ' ) op . outputs = sorted ( glob ( 'static/Example_4/example_*.txt' )) op . collect_results ( scaled = True ) m = op . summary assert len ( m ) == 6 assert 'T1' in m . columns and 'T2' in m . columns and 'wph' in m . columns assert round ( m . wph [ 0 ], 3 ) == 5.491 assert round ( m . wph [ 4 ], 3 ) == 21.084 # the value shown in the OP manual @staticmethod def test_budget_formats (): ''' Test the function that generates budget labels. ''' assert list ( OP . format_budgets ([ n * 1000000 for n in range ( 1 , 6 )]) . values ()) == [ '$1M' , '$2M' , '$3M' , '$4M' , '$5M' ] assert list ( OP . format_budgets ([ n * 100000 for n in range ( 1 , 6 )]) . values ()) == [ '$100K' , '$200K' , '$300K' , '$400K' , '$500K' ] assert list ( OP . format_budgets ([ n * 500000 for n in range ( 1 , 6 )]) . values ()) == [ '$500K' , '$1M' , '$1.5M' , '$2M' , '$2.5M' ] test_budget_formats () staticmethod Test the function that generates budget labels. src/tidegates/optipass.py 586 587 588 589 590 591 592 593 @staticmethod def test_budget_formats (): ''' Test the function that generates budget labels. ''' assert list ( OP . format_budgets ([ n * 1000000 for n in range ( 1 , 6 )]) . values ()) == [ '$1M' , '$2M' , '$3M' , '$4M' , '$5M' ] assert list ( OP . format_budgets ([ n * 100000 for n in range ( 1 , 6 )]) . values ()) == [ '$100K' , '$200K' , '$300K' , '$400K' , '$500K' ] assert list ( OP . format_budgets ([ n * 500000 for n in range ( 1 , 6 )]) . values ()) == [ '$500K' , '$1M' , '$1.5M' , '$2M' , '$2.5M' ] test_example_1 () staticmethod Test the OPResults class by collecting results for Example 1 from the OptiPass User Manual. src/tidegates/optipass.py 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 @staticmethod def test_example_1 (): ''' Test the OPResults class by collecting results for Example 1 from the OptiPass User Manual. ''' op = OP ( Project ( 'static/test_wb.csv' , DataSet . OPM ), [ 'OPM' ], [ 'T1' ], [ '1' ], None ) op . input_frame = pd . read_csv ( 'static/Example_1/Example1.txt' , sep = ' \\t ' ) op . outputs = sorted ( glob ( 'static/Example_1/example_*.txt' )) op . collect_results ( scaled = True ) assert len ( op . targets ) == 1 assert op . targets [ 0 ] . abbrev == 'T1' # assert len(op.weights) == 1 and round(op.weights[0]) == 1 assert type ( op . summary ) == pd . DataFrame assert len ( op . summary ) == 6 assert round ( op . summary . budget . sum ()) == 1500 assert round ( op . summary . habitat . sum (), 2 ) == 23.30 budget_cols = [ col for col in op . matrix . columns if isinstance ( col , int )] assert budget_cols == list ( op . summary . budget ) # these comprehensions make lists of budgets where a specified gate was selected assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'A' , b ]] == [ 400 , 500 ] assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'D' , b ]] == [ ] assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'E' , b ]] == [ 100 , 300 ] assert op . paths [ 'E' ] == [ 'E' , 'D' , 'A' ] assert op . paths [ 'A' ] == [ 'A' ] test_example_4 () staticmethod Same as test_example_1, but using Example 4, which has two restoration targets. src/tidegates/optipass.py 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 @staticmethod def test_example_4 (): ''' Same as test_example_1, but using Example 4, which has two restoration targets. ''' op = OP ( Project ( 'static/test_wb.csv' , DataSet . OPM ), [ 'OPM' ], [ 'T1' , 'T2' ], [ '3' , '1' ], None ) op . input_frame = pd . read_csv ( 'static/Example_4/Example4.txt' , sep = ' \\t ' ) op . outputs = sorted ( glob ( 'static/Example_4/example_*.txt' )) op . collect_results ( scaled = True ) assert len ( op . targets ) == 2 assert op . targets [ 0 ] . abbrev == 'T1' and op . targets [ 1 ] . abbrev == 'T2' assert len ( op . weights ) == 2 and round ( sum ( op . weights )) == 4 assert type ( op . summary ) == pd . DataFrame assert len ( op . summary ) == 6 assert round ( op . summary . budget . sum ()) == 1500 assert round ( op . summary . habitat . sum (), 2 ) == 95.21 # using two targets does not change the gate selections assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'A' , b ]] == [ 400 , 500 ] assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'D' , b ]] == [ ] assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'E' , b ]] == [ 100 , 300 ] test_generate_frame () staticmethod Test the structure of a frame that will be printed as a 'barrier file' for input to OptiPass src/tidegates/optipass.py 481 482 483 484 485 486 487 488 489 490 491 492 493 @staticmethod def test_generate_frame (): ''' Test the structure of a frame that will be printed as a 'barrier file' for input to OptiPass ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) op = OP ( p , [ 'Coos' ], [ 'CO' , 'CH' ], [ '1' , '1' ], 'Current' ) op . generate_input_frame () tf = op . input_frame assert list ( tf . columns ) == [ 'ID' , 'REG' , 'FOCUS' , 'DSID' , 'HAB_CO' , 'HAB_CH' , 'PRE_CO' , 'PRE_CH' , 'NPROJ' , 'ACTION' , 'COST' , 'POST_CO' , 'POST_CH' ] test_instantiate_object () staticmethod Test the OP constructor. src/tidegates/optipass.py 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 @staticmethod def test_instantiate_object (): ''' Test the OP constructor. ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) op = OP ( p , [ 'Coos' ], [ 'CO' , 'CH' ], [ '1' , '1' ], 'Current' ) assert op . project == p assert op . regions == [ 'Coos' ] assert op . climate == 'Current' assert op . weights == [ 1 , 1 ] assert len ( op . targets ) == 2 t = op . targets [ 0 ] assert t . abbrev == 'CO' assert t . short == 'Coho' assert t . long == 'Coho Streams' test_potential_habitat_1 () staticmethod Test the method that computes potential habitat, using the results genearated for Example 1 in the OptiPass manual. src/tidegates/optipass.py 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 @staticmethod def test_potential_habitat_1 (): ''' Test the method that computes potential habitat, using the results genearated for Example 1 in the OptiPass manual. ''' op = OP ( Project ( 'static/test_wb.csv' , DataSet . OPM ), [ 'OPM' ], [ 'T1' ], [ '1' ], None ) op . input_frame = pd . read_csv ( 'static/Example_1/Example1.txt' , sep = ' \\t ' ) op . outputs = sorted ( glob ( 'static/Example_1/example_*.txt' )) op . collect_results ( scaled = True ) m = op . summary assert len ( m ) == 6 assert 'T1' in m . columns and 'wph' in m . columns assert round ( m . wph [ 0 ], 3 ) == 1.238 assert round ( m . wph [ 5 ], 3 ) == 8.520 test_potential_habitat_4 () staticmethod Same as test_potential_habitat_1, but using Example 4, with two restoration targets src/tidegates/optipass.py 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 @staticmethod def test_potential_habitat_4 (): ''' Same as test_potential_habitat_1, but using Example 4, with two restoration targets ''' op = OP ( Project ( 'static/test_wb.csv' , DataSet . OPM ), [ 'OPM' ], [ 'T1' , 'T2' ], [ '3' , '1' ], None ) op . input_frame = pd . read_csv ( 'static/Example_4/Example4.txt' , sep = ' \\t ' ) op . outputs = sorted ( glob ( 'static/Example_4/example_*.txt' )) op . collect_results ( scaled = True ) m = op . summary assert len ( m ) == 6 assert 'T1' in m . columns and 'T2' in m . columns and 'wph' in m . columns assert round ( m . wph [ 0 ], 3 ) == 5.491 assert round ( m . wph [ 4 ], 3 ) == 21.084 # the value shown in the OP manual","title":"Tests"},{"location":"tests/#integration-tests","text":"Integration tests are implemented in the top level application ( main.py ). To perorm a test, run main with options that specify which type of test to run and where to find the data for the test. See the documentation for main.py for details and examples.","title":"Integration Tests"},{"location":"tests/#unit-tests","text":"If a module has unit tests they are included in the source file. Tests are defined at the end of the file, in a class that has a name that starts with Test . For example, project.py defines a class named Project, and at the end of the file is another class named TestProject. A test class defines a series of static methods that have names beginning with test . These methods are run in order. To run tests for a module, open a terminal window and cd to the top level folder. Then type a command that runs pytest , including the name of the module to test: $ pytest src/tidegates/project.py It's also possible to run all the tests with a single shell command: $ pytest src/tidegates/*.py","title":"Unit Tests"},{"location":"tests/#testproject","text":"Source code in src/tidegates/project.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 class TestProject : @staticmethod def test_load (): ''' Load the test data frame, expect to find 6 rows, with single letter barrier IDs ''' p = Project ( 'static/test_wb.csv' , DataSet . OPM ) assert isinstance ( p . data , pd . DataFrame ) assert len ( p . data ) == 6 assert list ( p . data . BARID ) == list ( 'ABCDEF' ) @staticmethod def test_regions (): ''' The list of region names should be sorted from north to south ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) assert len ( p . regions ) == 15 assert p . regions [ 0 ] == 'Columbia' assert p . regions [ - 1 ] == 'Coquille' @staticmethod def test_map_info (): ''' The frame with map information should have 5 columns ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) assert isinstance ( p . map_info , pd . DataFrame ) assert len ( p . map_info ) == len ( p . data ) assert list ( p . map_info . columns ) == [ 'id' , 'region' , 'type' , 'x' , 'y' ] @staticmethod def test_targets (): ''' There should be two sets of targets, each with 10 entries, and one entry for each target in the map. ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) assert len ( p . targets ) == 2 assert len ( p . targets [ 'Current' ]) == 10 assert len ( p . targets [ 'Future' ]) == 10 t = p . targets [ 'Current' ][ 'CO' ] assert t . short == 'Coho' assert t . long == 'Coho Streams' assert t . habitat == 'sCO' assert t . prepass == 'PREPASS_CO' assert t . postpass == 'POSTPASS' assert len ( p . target_map ) == 10 assert p . target_map [ 'Coho Streams' ] == 'CO'","title":"TestProject"},{"location":"tests/#src.tidegates.project.TestProject.test_load","text":"Load the test data frame, expect to find 6 rows, with single letter barrier IDs src/tidegates/project.py 84 85 86 87 88 89 90 91 92 93 @staticmethod def test_load (): ''' Load the test data frame, expect to find 6 rows, with single letter barrier IDs ''' p = Project ( 'static/test_wb.csv' , DataSet . OPM ) assert isinstance ( p . data , pd . DataFrame ) assert len ( p . data ) == 6 assert list ( p . data . BARID ) == list ( 'ABCDEF' )","title":"test_load()"},{"location":"tests/#src.tidegates.project.TestProject.test_map_info","text":"The frame with map information should have 5 columns src/tidegates/project.py 105 106 107 108 109 110 111 112 113 @staticmethod def test_map_info (): ''' The frame with map information should have 5 columns ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) assert isinstance ( p . map_info , pd . DataFrame ) assert len ( p . map_info ) == len ( p . data ) assert list ( p . map_info . columns ) == [ 'id' , 'region' , 'type' , 'x' , 'y' ]","title":"test_map_info()"},{"location":"tests/#src.tidegates.project.TestProject.test_regions","text":"The list of region names should be sorted from north to south src/tidegates/project.py 95 96 97 98 99 100 101 102 103 @staticmethod def test_regions (): ''' The list of region names should be sorted from north to south ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) assert len ( p . regions ) == 15 assert p . regions [ 0 ] == 'Columbia' assert p . regions [ - 1 ] == 'Coquille'","title":"test_regions()"},{"location":"tests/#src.tidegates.project.TestProject.test_targets","text":"There should be two sets of targets, each with 10 entries, and one entry for each target in the map. src/tidegates/project.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 @staticmethod def test_targets (): ''' There should be two sets of targets, each with 10 entries, and one entry for each target in the map. ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) assert len ( p . targets ) == 2 assert len ( p . targets [ 'Current' ]) == 10 assert len ( p . targets [ 'Future' ]) == 10 t = p . targets [ 'Current' ][ 'CO' ] assert t . short == 'Coho' assert t . long == 'Coho Streams' assert t . habitat == 'sCO' assert t . prepass == 'PREPASS_CO' assert t . postpass == 'POSTPASS' assert len ( p . target_map ) == 10 assert p . target_map [ 'Coho Streams' ] == 'CO'","title":"test_targets()"},{"location":"tests/#testtargets","text":"Source code in src/tidegates/targets.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class TestTargets : @staticmethod def test_TNC_columns (): ''' Make sure the column names in the Target objects are the same as the column names in the data file ''' with open ( 'static/workbook.csv' ) as f : cols = f . readline () . strip () . split ( ',' ) targets = make_targets ( DataSet . TNC_OR ) for s in [ 'Current' , 'Future' ]: for t in targets [ s ] . values (): assert t . habitat in cols assert t . prepass in cols assert t . postpass in cols assert t . unscaled in cols @staticmethod def test_OPM_columns (): with open ( 'static/test_wb.csv' ) as f : cols = f . readline () . strip () . split ( ',' ) targets = make_targets ( DataSet . OPM ) for s in [ '1' , '2' ]: name = 'T' + s assert name in targets t = targets [ name ] assert t . habitat in cols assert t . prepass in cols assert t . postpass in cols","title":"TestTargets"},{"location":"tests/#src.tidegates.targets.TestTargets.test_TNC_columns","text":"Make sure the column names in the Target objects are the same as the column names in the data file src/tidegates/targets.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @staticmethod def test_TNC_columns (): ''' Make sure the column names in the Target objects are the same as the column names in the data file ''' with open ( 'static/workbook.csv' ) as f : cols = f . readline () . strip () . split ( ',' ) targets = make_targets ( DataSet . TNC_OR ) for s in [ 'Current' , 'Future' ]: for t in targets [ s ] . values (): assert t . habitat in cols assert t . prepass in cols assert t . postpass in cols assert t . unscaled in cols","title":"test_TNC_columns()"},{"location":"tests/#testop","text":"Source code in src/tidegates/optipass.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 class TestOP : @staticmethod def test_instantiate_object (): ''' Test the OP constructor. ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) op = OP ( p , [ 'Coos' ], [ 'CO' , 'CH' ], [ '1' , '1' ], 'Current' ) assert op . project == p assert op . regions == [ 'Coos' ] assert op . climate == 'Current' assert op . weights == [ 1 , 1 ] assert len ( op . targets ) == 2 t = op . targets [ 0 ] assert t . abbrev == 'CO' assert t . short == 'Coho' assert t . long == 'Coho Streams' @staticmethod def test_generate_frame (): ''' Test the structure of a frame that will be printed as a 'barrier file' for input to OptiPass ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) op = OP ( p , [ 'Coos' ], [ 'CO' , 'CH' ], [ '1' , '1' ], 'Current' ) op . generate_input_frame () tf = op . input_frame assert list ( tf . columns ) == [ 'ID' , 'REG' , 'FOCUS' , 'DSID' , 'HAB_CO' , 'HAB_CH' , 'PRE_CO' , 'PRE_CH' , 'NPROJ' , 'ACTION' , 'COST' , 'POST_CO' , 'POST_CH' ] # NOTE: the OPM project does not have habitat in unscaled (\"target\") units # so the calls to collect_results in these tests need to specify scaled = True @staticmethod def test_example_1 (): ''' Test the OPResults class by collecting results for Example 1 from the OptiPass User Manual. ''' op = OP ( Project ( 'static/test_wb.csv' , DataSet . OPM ), [ 'OPM' ], [ 'T1' ], [ '1' ], None ) op . input_frame = pd . read_csv ( 'static/Example_1/Example1.txt' , sep = ' \\t ' ) op . outputs = sorted ( glob ( 'static/Example_1/example_*.txt' )) op . collect_results ( scaled = True ) assert len ( op . targets ) == 1 assert op . targets [ 0 ] . abbrev == 'T1' # assert len(op.weights) == 1 and round(op.weights[0]) == 1 assert type ( op . summary ) == pd . DataFrame assert len ( op . summary ) == 6 assert round ( op . summary . budget . sum ()) == 1500 assert round ( op . summary . habitat . sum (), 2 ) == 23.30 budget_cols = [ col for col in op . matrix . columns if isinstance ( col , int )] assert budget_cols == list ( op . summary . budget ) # these comprehensions make lists of budgets where a specified gate was selected assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'A' , b ]] == [ 400 , 500 ] assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'D' , b ]] == [ ] assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'E' , b ]] == [ 100 , 300 ] assert op . paths [ 'E' ] == [ 'E' , 'D' , 'A' ] assert op . paths [ 'A' ] == [ 'A' ] @staticmethod def test_example_4 (): ''' Same as test_example_1, but using Example 4, which has two restoration targets. ''' op = OP ( Project ( 'static/test_wb.csv' , DataSet . OPM ), [ 'OPM' ], [ 'T1' , 'T2' ], [ '3' , '1' ], None ) op . input_frame = pd . read_csv ( 'static/Example_4/Example4.txt' , sep = ' \\t ' ) op . outputs = sorted ( glob ( 'static/Example_4/example_*.txt' )) op . collect_results ( scaled = True ) assert len ( op . targets ) == 2 assert op . targets [ 0 ] . abbrev == 'T1' and op . targets [ 1 ] . abbrev == 'T2' assert len ( op . weights ) == 2 and round ( sum ( op . weights )) == 4 assert type ( op . summary ) == pd . DataFrame assert len ( op . summary ) == 6 assert round ( op . summary . budget . sum ()) == 1500 assert round ( op . summary . habitat . sum (), 2 ) == 95.21 # using two targets does not change the gate selections assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'A' , b ]] == [ 400 , 500 ] assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'D' , b ]] == [ ] assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'E' , b ]] == [ 100 , 300 ] @staticmethod def test_potential_habitat_1 (): ''' Test the method that computes potential habitat, using the results genearated for Example 1 in the OptiPass manual. ''' op = OP ( Project ( 'static/test_wb.csv' , DataSet . OPM ), [ 'OPM' ], [ 'T1' ], [ '1' ], None ) op . input_frame = pd . read_csv ( 'static/Example_1/Example1.txt' , sep = ' \\t ' ) op . outputs = sorted ( glob ( 'static/Example_1/example_*.txt' )) op . collect_results ( scaled = True ) m = op . summary assert len ( m ) == 6 assert 'T1' in m . columns and 'wph' in m . columns assert round ( m . wph [ 0 ], 3 ) == 1.238 assert round ( m . wph [ 5 ], 3 ) == 8.520 @staticmethod def test_potential_habitat_4 (): ''' Same as test_potential_habitat_1, but using Example 4, with two restoration targets ''' op = OP ( Project ( 'static/test_wb.csv' , DataSet . OPM ), [ 'OPM' ], [ 'T1' , 'T2' ], [ '3' , '1' ], None ) op . input_frame = pd . read_csv ( 'static/Example_4/Example4.txt' , sep = ' \\t ' ) op . outputs = sorted ( glob ( 'static/Example_4/example_*.txt' )) op . collect_results ( scaled = True ) m = op . summary assert len ( m ) == 6 assert 'T1' in m . columns and 'T2' in m . columns and 'wph' in m . columns assert round ( m . wph [ 0 ], 3 ) == 5.491 assert round ( m . wph [ 4 ], 3 ) == 21.084 # the value shown in the OP manual @staticmethod def test_budget_formats (): ''' Test the function that generates budget labels. ''' assert list ( OP . format_budgets ([ n * 1000000 for n in range ( 1 , 6 )]) . values ()) == [ '$1M' , '$2M' , '$3M' , '$4M' , '$5M' ] assert list ( OP . format_budgets ([ n * 100000 for n in range ( 1 , 6 )]) . values ()) == [ '$100K' , '$200K' , '$300K' , '$400K' , '$500K' ] assert list ( OP . format_budgets ([ n * 500000 for n in range ( 1 , 6 )]) . values ()) == [ '$500K' , '$1M' , '$1.5M' , '$2M' , '$2.5M' ]","title":"TestOP"},{"location":"tests/#src.tidegates.optipass.TestOP.test_budget_formats","text":"Test the function that generates budget labels. src/tidegates/optipass.py 586 587 588 589 590 591 592 593 @staticmethod def test_budget_formats (): ''' Test the function that generates budget labels. ''' assert list ( OP . format_budgets ([ n * 1000000 for n in range ( 1 , 6 )]) . values ()) == [ '$1M' , '$2M' , '$3M' , '$4M' , '$5M' ] assert list ( OP . format_budgets ([ n * 100000 for n in range ( 1 , 6 )]) . values ()) == [ '$100K' , '$200K' , '$300K' , '$400K' , '$500K' ] assert list ( OP . format_budgets ([ n * 500000 for n in range ( 1 , 6 )]) . values ()) == [ '$500K' , '$1M' , '$1.5M' , '$2M' , '$2.5M' ]","title":"test_budget_formats()"},{"location":"tests/#src.tidegates.optipass.TestOP.test_example_1","text":"Test the OPResults class by collecting results for Example 1 from the OptiPass User Manual. src/tidegates/optipass.py 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 @staticmethod def test_example_1 (): ''' Test the OPResults class by collecting results for Example 1 from the OptiPass User Manual. ''' op = OP ( Project ( 'static/test_wb.csv' , DataSet . OPM ), [ 'OPM' ], [ 'T1' ], [ '1' ], None ) op . input_frame = pd . read_csv ( 'static/Example_1/Example1.txt' , sep = ' \\t ' ) op . outputs = sorted ( glob ( 'static/Example_1/example_*.txt' )) op . collect_results ( scaled = True ) assert len ( op . targets ) == 1 assert op . targets [ 0 ] . abbrev == 'T1' # assert len(op.weights) == 1 and round(op.weights[0]) == 1 assert type ( op . summary ) == pd . DataFrame assert len ( op . summary ) == 6 assert round ( op . summary . budget . sum ()) == 1500 assert round ( op . summary . habitat . sum (), 2 ) == 23.30 budget_cols = [ col for col in op . matrix . columns if isinstance ( col , int )] assert budget_cols == list ( op . summary . budget ) # these comprehensions make lists of budgets where a specified gate was selected assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'A' , b ]] == [ 400 , 500 ] assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'D' , b ]] == [ ] assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'E' , b ]] == [ 100 , 300 ] assert op . paths [ 'E' ] == [ 'E' , 'D' , 'A' ] assert op . paths [ 'A' ] == [ 'A' ]","title":"test_example_1()"},{"location":"tests/#src.tidegates.optipass.TestOP.test_example_4","text":"Same as test_example_1, but using Example 4, which has two restoration targets. src/tidegates/optipass.py 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 @staticmethod def test_example_4 (): ''' Same as test_example_1, but using Example 4, which has two restoration targets. ''' op = OP ( Project ( 'static/test_wb.csv' , DataSet . OPM ), [ 'OPM' ], [ 'T1' , 'T2' ], [ '3' , '1' ], None ) op . input_frame = pd . read_csv ( 'static/Example_4/Example4.txt' , sep = ' \\t ' ) op . outputs = sorted ( glob ( 'static/Example_4/example_*.txt' )) op . collect_results ( scaled = True ) assert len ( op . targets ) == 2 assert op . targets [ 0 ] . abbrev == 'T1' and op . targets [ 1 ] . abbrev == 'T2' assert len ( op . weights ) == 2 and round ( sum ( op . weights )) == 4 assert type ( op . summary ) == pd . DataFrame assert len ( op . summary ) == 6 assert round ( op . summary . budget . sum ()) == 1500 assert round ( op . summary . habitat . sum (), 2 ) == 95.21 # using two targets does not change the gate selections assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'A' , b ]] == [ 400 , 500 ] assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'D' , b ]] == [ ] assert [ b for b in op . matrix . columns if b != 'count' and op . matrix . loc [ 'E' , b ]] == [ 100 , 300 ]","title":"test_example_4()"},{"location":"tests/#src.tidegates.optipass.TestOP.test_generate_frame","text":"Test the structure of a frame that will be printed as a 'barrier file' for input to OptiPass src/tidegates/optipass.py 481 482 483 484 485 486 487 488 489 490 491 492 493 @staticmethod def test_generate_frame (): ''' Test the structure of a frame that will be printed as a 'barrier file' for input to OptiPass ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) op = OP ( p , [ 'Coos' ], [ 'CO' , 'CH' ], [ '1' , '1' ], 'Current' ) op . generate_input_frame () tf = op . input_frame assert list ( tf . columns ) == [ 'ID' , 'REG' , 'FOCUS' , 'DSID' , 'HAB_CO' , 'HAB_CH' , 'PRE_CO' , 'PRE_CH' , 'NPROJ' , 'ACTION' , 'COST' , 'POST_CO' , 'POST_CH' ]","title":"test_generate_frame()"},{"location":"tests/#src.tidegates.optipass.TestOP.test_instantiate_object","text":"Test the OP constructor. src/tidegates/optipass.py 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 @staticmethod def test_instantiate_object (): ''' Test the OP constructor. ''' p = Project ( 'static/workbook.csv' , DataSet . TNC_OR ) op = OP ( p , [ 'Coos' ], [ 'CO' , 'CH' ], [ '1' , '1' ], 'Current' ) assert op . project == p assert op . regions == [ 'Coos' ] assert op . climate == 'Current' assert op . weights == [ 1 , 1 ] assert len ( op . targets ) == 2 t = op . targets [ 0 ] assert t . abbrev == 'CO' assert t . short == 'Coho' assert t . long == 'Coho Streams'","title":"test_instantiate_object()"},{"location":"tests/#src.tidegates.optipass.TestOP.test_potential_habitat_1","text":"Test the method that computes potential habitat, using the results genearated for Example 1 in the OptiPass manual. src/tidegates/optipass.py 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 @staticmethod def test_potential_habitat_1 (): ''' Test the method that computes potential habitat, using the results genearated for Example 1 in the OptiPass manual. ''' op = OP ( Project ( 'static/test_wb.csv' , DataSet . OPM ), [ 'OPM' ], [ 'T1' ], [ '1' ], None ) op . input_frame = pd . read_csv ( 'static/Example_1/Example1.txt' , sep = ' \\t ' ) op . outputs = sorted ( glob ( 'static/Example_1/example_*.txt' )) op . collect_results ( scaled = True ) m = op . summary assert len ( m ) == 6 assert 'T1' in m . columns and 'wph' in m . columns assert round ( m . wph [ 0 ], 3 ) == 1.238 assert round ( m . wph [ 5 ], 3 ) == 8.520","title":"test_potential_habitat_1()"},{"location":"tests/#src.tidegates.optipass.TestOP.test_potential_habitat_4","text":"Same as test_potential_habitat_1, but using Example 4, with two restoration targets src/tidegates/optipass.py 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 @staticmethod def test_potential_habitat_4 (): ''' Same as test_potential_habitat_1, but using Example 4, with two restoration targets ''' op = OP ( Project ( 'static/test_wb.csv' , DataSet . OPM ), [ 'OPM' ], [ 'T1' , 'T2' ], [ '3' , '1' ], None ) op . input_frame = pd . read_csv ( 'static/Example_4/Example4.txt' , sep = ' \\t ' ) op . outputs = sorted ( glob ( 'static/Example_4/example_*.txt' )) op . collect_results ( scaled = True ) m = op . summary assert len ( m ) == 6 assert 'T1' in m . columns and 'T2' in m . columns and 'wph' in m . columns assert round ( m . wph [ 0 ], 3 ) == 5.491 assert round ( m . wph [ 4 ], 3 ) == 21.084 # the value shown in the OP manual","title":"test_potential_habitat_4()"},{"location":"user/","text":"How to Use the Optimzation Tool TBD","title":"How to Use the Optimzation Tool"},{"location":"user/#how-to-use-the-optimzation-tool","text":"TBD","title":"How to Use the Optimzation Tool"},{"location":"widgets/","text":"Widget Classes The GUI displayed in a user's browser shows dozens of graphical elements. These \"widgets\" include checkboxes that allow users to select geographic regions and restoration targets, sliders to specify budget levels, and buttons that run the optimizer or show help messages. If all these widgets are defined in a single module the code will be very messy. Instead, the web app uses a common technique: we define our own widget classes, using inheritance so our objects are a special case of an existing type of widget. A good example is a class named RegionBox. Instead of having 15 separate checkboxes, one for each region in the Oregon Coast data set, we make just one object, an instance of our new RegionBox class. We pass a Project object to the function that creates this object, and the function scans the data to find all the region names, automatically making one checkbox for each separate region. All these checkboxes are stored internally, inside the RegionBox, keeping our code nice and tidy. The Python syntax for defining a new class that is derived from an existing class uses a class statement. This is the statement that defines the RegionBox class: class RegionBox(pn.Column): ... pn.Column is an existing widget class, defined in the Panel library. That means our new RegionBox objects will be special types of columns that can be inserted into the GUI at some place. The code that is called to create a new object is a function named __init__ defined inside the class. The first argument to __init__ is always self , which is a reference to the object being built. Here is a simplified version of the __init__ function for the RegionBox class (the actual definition is shown below, in the documentation for RegionBox): class RegionBox(pn.Column): def __init__(self, project): boxes = [] for name in project.regions: box = pn.widgets.Checkbox(name=name, styles=box_styles) box.param.watch(self.cb, ['value']) boxes.append(box) self.grid = pn.GridBox(*boxes, ncols=3) When this function is called, it initializes a variable named boxes to be an empty list. The for loop iterates over all the region names (which are part of the Project object passed to the function). It makes a Checkbox widget for each region and adds the box to the list of boxes. At the end of the loop all the boxes are put into a grid with three columns. The line in the middle of the loop that calls box.param.watch is where all the \"magic\" happens. This function call tells the GUI that whenever a checkbox is clicked it should call a function named cb that is also defined inside the RegionBox class. Here is a simplified version: def cb(self, event): r = event.obj.name if event.new: self.selected.add(r) else: self.selected.remove(r) The name cb is short for \"callback\", a common name for this type of function. The parameter named event has information about what the user just did. In this case, we want to get the name of the button (which will be one of the region names) and then update the set of selected regions. If the button was turned on we add the region name to the set, otherwise we remove it.","title":"Widget Classes"},{"location":"widgets/#widget-classes","text":"The GUI displayed in a user's browser shows dozens of graphical elements. These \"widgets\" include checkboxes that allow users to select geographic regions and restoration targets, sliders to specify budget levels, and buttons that run the optimizer or show help messages. If all these widgets are defined in a single module the code will be very messy. Instead, the web app uses a common technique: we define our own widget classes, using inheritance so our objects are a special case of an existing type of widget. A good example is a class named RegionBox. Instead of having 15 separate checkboxes, one for each region in the Oregon Coast data set, we make just one object, an instance of our new RegionBox class. We pass a Project object to the function that creates this object, and the function scans the data to find all the region names, automatically making one checkbox for each separate region. All these checkboxes are stored internally, inside the RegionBox, keeping our code nice and tidy. The Python syntax for defining a new class that is derived from an existing class uses a class statement. This is the statement that defines the RegionBox class: class RegionBox(pn.Column): ... pn.Column is an existing widget class, defined in the Panel library. That means our new RegionBox objects will be special types of columns that can be inserted into the GUI at some place. The code that is called to create a new object is a function named __init__ defined inside the class. The first argument to __init__ is always self , which is a reference to the object being built. Here is a simplified version of the __init__ function for the RegionBox class (the actual definition is shown below, in the documentation for RegionBox): class RegionBox(pn.Column): def __init__(self, project): boxes = [] for name in project.regions: box = pn.widgets.Checkbox(name=name, styles=box_styles) box.param.watch(self.cb, ['value']) boxes.append(box) self.grid = pn.GridBox(*boxes, ncols=3) When this function is called, it initializes a variable named boxes to be an empty list. The for loop iterates over all the region names (which are part of the Project object passed to the function). It makes a Checkbox widget for each region and adds the box to the list of boxes. At the end of the loop all the boxes are put into a grid with three columns. The line in the middle of the loop that calls box.param.watch is where all the \"magic\" happens. This function call tells the GUI that whenever a checkbox is clicked it should call a function named cb that is also defined inside the RegionBox class. Here is a simplified version: def cb(self, event): r = event.obj.name if event.new: self.selected.add(r) else: self.selected.remove(r) The name cb is short for \"callback\", a common name for this type of function. The parameter named event has information about what the user just did. In this case, we want to get the name of the button (which will be one of the region names) and then update the set of selected regions. If the button was turned on we add the region name to the set, otherwise we remove it.","title":"Widget Classes"}]}
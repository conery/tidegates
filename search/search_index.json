{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Overview.</p>"},{"location":"#instructions-for-users","title":"Instructions for Users","text":"<p>see...</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#running-the-server","title":"Running the Server","text":""},{"location":"#run-locally-for-testing-and-development","title":"Run Locally for Testing and Development","text":""},{"location":"#deploying-on-a-server","title":"Deploying on a Server","text":""},{"location":"#technical-documentation","title":"Technical Documentation","text":""},{"location":"developer/","title":"Technical Documentation","text":"<p>Descriptions of Python files</p>"},{"location":"developer/#optipass.OP","title":"<code>OP</code>","text":"Source code in <code>optipass.py</code> <pre><code>class OP:\n\n    def __init__(self, project: Project, regions: list[str], targets: list[str], weights: list[str], climate: str):\n        '''\n        Instantiate a new OP object.\n        * project is a Project object containing barrier data\n        * regions is a list of unique names from the barrier file\n        * targets is a list of 2-letter target IDs\n        * climate is either 'Current' or 'Future'\n        '''\n        self.project = project\n        self.regions = regions\n        if weights:\n            self.weights = [int(s) for s in weights]\n            self.weighted = True\n        else:\n            self.weights = [1] * len(targets)\n            self.weighted = False\n        self.climate = climate\n        structs = self.project.targets[climate] if climate else self.project.targets\n        self.targets = [structs[t] for t in targets]\n        self.input_frame = None\n        self.outputs = None\n\n    def generate_input_frame(self):\n        '''\n        Create a data frame that will be written in the format of a \"barrier\n        file\" that will be read by OptiPass.  Save the frame as the\n        input_frame attribute of the object.\n        '''\n\n        filtered = self.project.data[self.project.data.REGION.isin(self.regions)]\n        filtered.index = list(range(len(filtered)))\n\n        df = filtered[['BARID','REGION']]\n        header = ['ID','REG']\n\n        df = pd.concat([df, pd.Series(np.ones(len(filtered)), name='FOCUS', dtype=int)], axis=1)\n        header.append('FOCUS')\n\n        df = pd.concat([df, filtered['DSID']], axis=1)\n        header.append('DSID')\n\n        for t in self.targets:\n            df = pd.concat([df, filtered[t.habitat]], axis=1)\n            header.append('HAB_'+t.abbrev)\n\n        for t in self.targets:\n            df = pd.concat([df, filtered[t.prepass]], axis=1)\n            header.append('PRE_'+t.abbrev)\n\n        df = pd.concat([df, filtered['NPROJ']], axis=1)\n        header.append('NPROJ')\n\n        df = pd.concat([df, pd.Series(np.zeros(len(filtered)), name='ACTION', dtype=int)], axis=1)\n        header.append('ACTION')\n\n        df = pd.concat([df, filtered['COST']], axis=1)\n        header += ['COST']\n\n        for t in self.targets:\n            df = pd.concat([df, filtered[t.postpass]], axis=1)\n            header.append('POST_'+t.abbrev)\n\n        df.columns = header\n        self.input_frame = df\n\n        return df\n\n    # To run OptiPass we need (a) a Windows host with the OptiPass command line version\n    # or (b) a Linux host with WINE installed.  If the host OS is a Mac print an error\n    # message (WINE can't run on Apple silicon).\n\n    def run(self, budgets: list[int], preview: bool, progress_hook = lambda: 0):\n        '''\n        Generate and execute the shell commands that run OptiPass.  If the shell\n        environment includes a variable named WINEARCH it means the script is\n        running on Linux, and we need to use Wine, otherwise build a command that\n        will run on Windows.\n        '''\n        if platform.system() == 'Windows':\n            app = 'bin\\\\OptiPassMain.exe'\n        elif platform.system() == 'Linux' and os.environ.get('WINEARCH'):\n            app = 'wine bin/OptiPassMain.exe'\n        else:\n            Logging.log(f'{platform.system()} not configured to run WINE')\n            self.outputs = None\n            return\n\n        template = app + ' -f {bf} -o {of} -b {n}'\n\n        df = self.generate_input_frame()\n        _, barrier_file = tempfile.mkstemp(suffix='.txt', dir='./tmp', text=True)\n        df.to_csv(barrier_file, index=False, sep='\\t', lineterminator=os.linesep, na_rep='NA')\n\n        self.budget_max, self.budget_delta = budgets\n        num_budgets = self.budget_max // self.budget_delta\n        outputs = []\n        root, _ = os.path.splitext(barrier_file)\n        for i in range(num_budgets + 1):\n            outfile = f'{root}_{i+1}.txt'\n            budget = self.budget_delta * i\n            cmnd = template.format(bf=barrier_file, of=outfile, n=budget)\n            if (num_targets := len(self.targets)) &gt; 1:\n                cmnd += ' -t {}'.format(num_targets)\n                cmnd += ' -w ' + ', '.join([str(n) for n in self.weights])\n            Logging.log(cmnd)\n            print(cmnd)\n            if not preview:\n                res = subprocess.run(cmnd, shell=True, capture_output=True)\n                print(res.stdout)\n                print(res.stderr)\n            if preview or (res.returncode == 0):\n                outputs.append(outfile)\n                progress_hook()\n            else:\n                Logging.log('OptiPass failed:')\n                Logging.log(res.stderr)\n        self.outputs = outputs\n\n    def collect_results(self, scaled=False):\n        '''\n        Parse the output files produced by OptiPass\n        '''\n        df = self.input_frame\n        G = nx.from_pandas_edgelist(\n            df[df.DSID.notnull()], \n            source='ID', \n            target='DSID', \n            create_using=nx.DiGraph\n        )\n        for x in df[df.DSID.isnull()].ID:\n            G.add_node(x)\n        self.paths = { n: self._path_from(n,G) for n in G.nodes }\n\n        cols = { x: [] for x in ['budget', 'habitat', 'gates']}\n        for fn in self.outputs:\n            self._parse_op_output(fn, cols)\n        self.summary = pd.DataFrame(cols)\n\n        dct = {}\n        for i in range(len(self.summary)):\n            b = int(self.summary.budget[i])\n            dct[b] = [ 1 if g in self.summary.gates[i] else 0 for g in self.input_frame.ID]\n        self.matrix = pd.DataFrame(dct, index=self.input_frame.ID)\n        self.matrix['count'] = self.matrix.sum(axis=1)\n        self.potential_habitat(self.targets, scaled)\n\n    def _path_from(self, x, graph):\n        '''\n        Return a list of nodes in the path from `x` to a downstream barrier that\n        has no descendants.\n        '''\n        return [x] + [child for _, child in nx.dfs_edges(graph,x)]\n\n    def _parse_op_output(self, fn, dct):\n        '''\n        Parse an output file, appending results to the lists.  We need to handle\n        two different formats, depending on whether there was one target or more\n        than one.\n        '''\n\n        def parse_header_line(line, tag):\n            tokens = line.strip().split()\n            if not tokens[0].startswith(tag):\n                return None\n            return tokens[1]\n\n        with open(fn) as f:\n            amount = parse_header_line(f.readline(), 'BUDGET')\n            dct['budget'].append(float(amount))\n            if parse_header_line(f.readline(), 'STATUS') == 'NO_SOLN':\n                raise RuntimeError('No solution')\n            f.readline()                        # skip OPTGAP\n            line = f.readline()\n            if line.startswith('PTNL'):\n                # dct['weights'].append([1.0])\n                hab = parse_header_line(line, 'PTNL_HABITAT')\n                dct['habitat'].append(float(hab))\n                f.readline()                    # skip NETGAIN\n            else:\n                lst = []\n                while w := parse_header_line(f.readline(), 'TARGET'):\n                    lst.append(float(w))\n                # dct['weights'].append(lst)\n                while line := f.readline():      # skip the individual habitat lines\n                    if line.startswith('WT_PTNL_HAB'):\n                        break\n                hab = parse_header_line(line, 'WT_PTNL_HAB')\n                dct['habitat'].append(float(hab))\n                f.readline()                    # skip WT_NETGAIN\n            f.readline()                        # skip blank line\n            f.readline()                        # skip header\n            lst = []\n            while line := f.readline():\n                name, action = line.strip().split()\n                if action == '1':\n                    lst.append(name)\n            dct['gates'].append(lst)\n\n    def potential_habitat(self, tlist, scaled):\n        '''\n        Compute the potential habitat available before and after restoration, using\n        the original unscaled habitat values.\n        '''\n        filtered = self.project.data[self.project.data.REGION.isin(self.regions)].fillna(0)\n        filtered.index = filtered.BARID\n        wph = np.zeros(len(self.summary))\n        for i in range(len(tlist)):\n            t = self.targets[i]\n            cp = self._ah(t, filtered, scaled)\n            wph += (self.weights[i] * cp)\n            col = pd.DataFrame({t.abbrev: cp})\n            self.summary = pd.concat([self.summary, col], axis=1)\n            if not scaled:\n                gain = self._gain(t, filtered)\n                self.matrix = pd.concat([self.matrix, filtered[t.unscaled], gain], axis=1)\n\n        # If scaled is True add the wph column so we can compare with OP values\n        if scaled:\n            self.summary = pd.concat([self.summary, pd.DataFrame({'wph': wph})], axis = 1)\n        self.summary['netgain'] = self.summary.habitat - self.summary.habitat[0]\n        return self.summary\n\n    # Private method: compute the available habitat for a target, in the form of\n    # a vector of habitat values for each budget level\n\n    def _ah(self, target, data, scaled):\n        budgets = self.summary.budget\n        m = self.matrix\n        res = np.zeros(len(budgets))\n        for i in range(len(res)):\n            action = m.iloc[:,i]\n            pvec = data[target.postpass].where(action == 1, data[target.prepass])\n            habitat = data[target.habitat if scaled else target.unscaled]\n            res[i] = sum(prod(pvec[x] for x in self.paths[b]) * habitat[b] for b in m.index)\n        return res\n\n    def _gain(self, target, data):\n        col = (data[target.postpass] - data[target.prepass]) * data[target.unscaled]\n        return col.to_frame(name=f'GAIN_{target.abbrev}')\n\n    def table_view(self, test=False):\n        '''\n        Create a table that will be displayed by the GUI\n        '''\n        filtered = self.project.data[self.project.data.REGION.isin(self.regions)]\n        filtered = filtered.set_index('BARID')\n\n        if test:\n            info_cols = other_cols = { }\n        else:\n            info_cols = {\n                'REGION': 'Region',\n                'BarrierType': 'Type',\n                'DSID': 'DSID',\n                'COST': 'Cost',\n            }\n\n            other_cols = {\n                'PrimaryTG': 'Primary',\n                'DominantTG': 'Dominant',\n                'POINT_X': 'Longitude',\n                'POINT_Y': 'Latitude',\n            }\n\n        budget_cols = OP.format_budgets([c for c in self.matrix.columns if isinstance(c,int) and c &gt; 0])\n\n        df = pd.concat([\n            filtered[info_cols.keys()].rename(columns=info_cols),\n            self.matrix.rename(columns=budget_cols),\n            filtered[other_cols.keys()].rename(columns=other_cols),\n        ], axis=1)\n\n        dct = { t.unscaled: t.short+'_hab' for t in self.targets }\n        dct |= { f'GAIN_{t.abbrev}': t.short+'_gain' for t in self.targets }\n        df = df.rename(columns=dct)\n\n        del df[0]\n        df = df[df['count'] &gt; 0].sort_values(by='count', ascending=False).fillna('-')\n        df = df.rename(columns={'count': 'Count'})\n        df = df.reset_index(names=['ID'])\n\n        # df.columns = pd.MultiIndex.from_tuples(df.columns)\n        return df\n\n    @staticmethod\n    def format_budgets(cols):\n        return { n: OP.format_budget_amount(n) for n in cols }\n\n    dollar_format = {\n        'thou':  (1000, 'K'),\n        'mil':   (1000000, 'M'),\n    }\n\n    @staticmethod\n    def format_budget_amount(n):\n        divisor, suffix = OP.dollar_format['mil'] if n &gt;= 1000000 else OP.dollar_format['thou']\n        s = '${:}'.format(n/divisor)\n        if s.endswith('.0'):\n            s = s[:-2]\n        return s+suffix\n\n    def make_roi_curves(self):\n        figures = []\n        download_figures = []\n\n        climate = None\n\n        subtitle = 'Region: ' if len(self.regions) == 1 else 'Regions: '\n        subtitle +=  ', '.join(self.regions)\n\n        for i, t in enumerate(self.targets):\n            title = t.long\n            if t.infra:\n                climate = self.climate\n                title += f' ({climate} Climate)'\n            if self.weighted:\n                title += f' \u2a09 {int(self.weights[i])}'\n            f = self.bokeh_figure(self.summary.budget, self.summary[t.abbrev], title, subtitle, t.label)\n            figures.append((t.short, f))\n            f = self.pyplot_figure(self.summary.budget, self.summary[t.abbrev], title, subtitle, t.label)\n            download_figures.append((t.short, f))\n\n        if len(self.targets) &gt; 1:\n            title = 'Combined Potential Benefit'\n            if climate:\n                title += f' ({climate} Climate)'\n            f = self.bokeh_figure(self.summary.budget, self.summary.netgain, title, subtitle, 'Weighted Net Gain')\n            figures.insert(0, ('Net', f))\n            f = self.pyplot_figure(self.summary.budget, self.summary[t.abbrev], title, subtitle, 'Weighted Net Gain')\n            download_figures.insert(0, ('Net', f))\n\n        self.display_figures = figures\n        self.download_figures = download_figures\n\n    def bokeh_figure(self, x, y, title, subtitle, axis_label):\n        H = 400\n        W = 400\n        LW = 2\n        D = 10\n\n        f = figure(\n            # title=title, \n            x_axis_label='Budget', \n            y_axis_label=axis_label,\n            width=W,\n            height=H,\n            tools = [HoverTool(mode='vline')],\n            tooltips = 'Budget @x{$0.0a}, Benefit @y{0.0}',\n        )\n        f.line(x, y, line_width=LW)\n        f.circle(x, y, fill_color='white', size=D)\n        f.add_layout(Title(text=subtitle, text_font_style='italic'), 'above')\n        f.add_layout(Title(text=title), 'above')\n        f.xaxis.formatter = NumeralTickFormatter(format='$0.0a')\n        f.toolbar_location = None\n        return f\n\n    def pyplot_figure(self, x, y, title, subtitle, axis_label):\n\n        def tick_fmt(n, x):\n            return OP.format_budget_amount(n)\n\n        LC = '#3c76af'\n        H = 4\n        W = 4\n        LW = 1.25\n        D = 7\n\n        fig, ax = plt.subplots(figsize=(H,W))\n        fig.suptitle(title, fontsize=11, fontweight='bold')\n\n        ax.grid(linestyle='--', linewidth=0.5)\n        ax.plot(x, y, color=LC, linewidth=LW)\n        ax.plot(x, y, 'o', markerfacecolor='white', markeredgecolor=LC, markersize=D, markeredgewidth=0.75)\n        ax.xaxis.set_major_formatter(tick_fmt)\n        ax.set_title(subtitle, loc='left', fontstyle='oblique', fontsize= 10)\n        ax.set_ylabel(axis_label, style='italic', fontsize=10)\n        return fig\n</code></pre>"},{"location":"developer/#optipass.OP.__init__","title":"<code>__init__(project, regions, targets, weights, climate)</code>","text":"<p>Instantiate a new OP object. * project is a Project object containing barrier data * regions is a list of unique names from the barrier file * targets is a list of 2-letter target IDs * climate is either 'Current' or 'Future'</p> Source code in <code>optipass.py</code> <pre><code>def __init__(self, project: Project, regions: list[str], targets: list[str], weights: list[str], climate: str):\n    '''\n    Instantiate a new OP object.\n    * project is a Project object containing barrier data\n    * regions is a list of unique names from the barrier file\n    * targets is a list of 2-letter target IDs\n    * climate is either 'Current' or 'Future'\n    '''\n    self.project = project\n    self.regions = regions\n    if weights:\n        self.weights = [int(s) for s in weights]\n        self.weighted = True\n    else:\n        self.weights = [1] * len(targets)\n        self.weighted = False\n    self.climate = climate\n    structs = self.project.targets[climate] if climate else self.project.targets\n    self.targets = [structs[t] for t in targets]\n    self.input_frame = None\n    self.outputs = None\n</code></pre>"},{"location":"developer/#optipass.OP.collect_results","title":"<code>collect_results(scaled=False)</code>","text":"<p>Parse the output files produced by OptiPass</p> Source code in <code>optipass.py</code> <pre><code>def collect_results(self, scaled=False):\n    '''\n    Parse the output files produced by OptiPass\n    '''\n    df = self.input_frame\n    G = nx.from_pandas_edgelist(\n        df[df.DSID.notnull()], \n        source='ID', \n        target='DSID', \n        create_using=nx.DiGraph\n    )\n    for x in df[df.DSID.isnull()].ID:\n        G.add_node(x)\n    self.paths = { n: self._path_from(n,G) for n in G.nodes }\n\n    cols = { x: [] for x in ['budget', 'habitat', 'gates']}\n    for fn in self.outputs:\n        self._parse_op_output(fn, cols)\n    self.summary = pd.DataFrame(cols)\n\n    dct = {}\n    for i in range(len(self.summary)):\n        b = int(self.summary.budget[i])\n        dct[b] = [ 1 if g in self.summary.gates[i] else 0 for g in self.input_frame.ID]\n    self.matrix = pd.DataFrame(dct, index=self.input_frame.ID)\n    self.matrix['count'] = self.matrix.sum(axis=1)\n    self.potential_habitat(self.targets, scaled)\n</code></pre>"},{"location":"developer/#optipass.OP.generate_input_frame","title":"<code>generate_input_frame()</code>","text":"<p>Create a data frame that will be written in the format of a \"barrier file\" that will be read by OptiPass.  Save the frame as the input_frame attribute of the object.</p> Source code in <code>optipass.py</code> <pre><code>def generate_input_frame(self):\n    '''\n    Create a data frame that will be written in the format of a \"barrier\n    file\" that will be read by OptiPass.  Save the frame as the\n    input_frame attribute of the object.\n    '''\n\n    filtered = self.project.data[self.project.data.REGION.isin(self.regions)]\n    filtered.index = list(range(len(filtered)))\n\n    df = filtered[['BARID','REGION']]\n    header = ['ID','REG']\n\n    df = pd.concat([df, pd.Series(np.ones(len(filtered)), name='FOCUS', dtype=int)], axis=1)\n    header.append('FOCUS')\n\n    df = pd.concat([df, filtered['DSID']], axis=1)\n    header.append('DSID')\n\n    for t in self.targets:\n        df = pd.concat([df, filtered[t.habitat]], axis=1)\n        header.append('HAB_'+t.abbrev)\n\n    for t in self.targets:\n        df = pd.concat([df, filtered[t.prepass]], axis=1)\n        header.append('PRE_'+t.abbrev)\n\n    df = pd.concat([df, filtered['NPROJ']], axis=1)\n    header.append('NPROJ')\n\n    df = pd.concat([df, pd.Series(np.zeros(len(filtered)), name='ACTION', dtype=int)], axis=1)\n    header.append('ACTION')\n\n    df = pd.concat([df, filtered['COST']], axis=1)\n    header += ['COST']\n\n    for t in self.targets:\n        df = pd.concat([df, filtered[t.postpass]], axis=1)\n        header.append('POST_'+t.abbrev)\n\n    df.columns = header\n    self.input_frame = df\n\n    return df\n</code></pre>"},{"location":"developer/#optipass.OP.potential_habitat","title":"<code>potential_habitat(tlist, scaled)</code>","text":"<p>Compute the potential habitat available before and after restoration, using the original unscaled habitat values.</p> Source code in <code>optipass.py</code> <pre><code>def potential_habitat(self, tlist, scaled):\n    '''\n    Compute the potential habitat available before and after restoration, using\n    the original unscaled habitat values.\n    '''\n    filtered = self.project.data[self.project.data.REGION.isin(self.regions)].fillna(0)\n    filtered.index = filtered.BARID\n    wph = np.zeros(len(self.summary))\n    for i in range(len(tlist)):\n        t = self.targets[i]\n        cp = self._ah(t, filtered, scaled)\n        wph += (self.weights[i] * cp)\n        col = pd.DataFrame({t.abbrev: cp})\n        self.summary = pd.concat([self.summary, col], axis=1)\n        if not scaled:\n            gain = self._gain(t, filtered)\n            self.matrix = pd.concat([self.matrix, filtered[t.unscaled], gain], axis=1)\n\n    # If scaled is True add the wph column so we can compare with OP values\n    if scaled:\n        self.summary = pd.concat([self.summary, pd.DataFrame({'wph': wph})], axis = 1)\n    self.summary['netgain'] = self.summary.habitat - self.summary.habitat[0]\n    return self.summary\n</code></pre>"},{"location":"developer/#optipass.OP.run","title":"<code>run(budgets, preview, progress_hook=lambda : 0)</code>","text":"<p>Generate and execute the shell commands that run OptiPass.  If the shell environment includes a variable named WINEARCH it means the script is running on Linux, and we need to use Wine, otherwise build a command that will run on Windows.</p> Source code in <code>optipass.py</code> <pre><code>def run(self, budgets: list[int], preview: bool, progress_hook = lambda: 0):\n    '''\n    Generate and execute the shell commands that run OptiPass.  If the shell\n    environment includes a variable named WINEARCH it means the script is\n    running on Linux, and we need to use Wine, otherwise build a command that\n    will run on Windows.\n    '''\n    if platform.system() == 'Windows':\n        app = 'bin\\\\OptiPassMain.exe'\n    elif platform.system() == 'Linux' and os.environ.get('WINEARCH'):\n        app = 'wine bin/OptiPassMain.exe'\n    else:\n        Logging.log(f'{platform.system()} not configured to run WINE')\n        self.outputs = None\n        return\n\n    template = app + ' -f {bf} -o {of} -b {n}'\n\n    df = self.generate_input_frame()\n    _, barrier_file = tempfile.mkstemp(suffix='.txt', dir='./tmp', text=True)\n    df.to_csv(barrier_file, index=False, sep='\\t', lineterminator=os.linesep, na_rep='NA')\n\n    self.budget_max, self.budget_delta = budgets\n    num_budgets = self.budget_max // self.budget_delta\n    outputs = []\n    root, _ = os.path.splitext(barrier_file)\n    for i in range(num_budgets + 1):\n        outfile = f'{root}_{i+1}.txt'\n        budget = self.budget_delta * i\n        cmnd = template.format(bf=barrier_file, of=outfile, n=budget)\n        if (num_targets := len(self.targets)) &gt; 1:\n            cmnd += ' -t {}'.format(num_targets)\n            cmnd += ' -w ' + ', '.join([str(n) for n in self.weights])\n        Logging.log(cmnd)\n        print(cmnd)\n        if not preview:\n            res = subprocess.run(cmnd, shell=True, capture_output=True)\n            print(res.stdout)\n            print(res.stderr)\n        if preview or (res.returncode == 0):\n            outputs.append(outfile)\n            progress_hook()\n        else:\n            Logging.log('OptiPass failed:')\n            Logging.log(res.stderr)\n    self.outputs = outputs\n</code></pre>"},{"location":"developer/#optipass.OP.table_view","title":"<code>table_view(test=False)</code>","text":"<p>Create a table that will be displayed by the GUI</p> Source code in <code>optipass.py</code> <pre><code>def table_view(self, test=False):\n    '''\n    Create a table that will be displayed by the GUI\n    '''\n    filtered = self.project.data[self.project.data.REGION.isin(self.regions)]\n    filtered = filtered.set_index('BARID')\n\n    if test:\n        info_cols = other_cols = { }\n    else:\n        info_cols = {\n            'REGION': 'Region',\n            'BarrierType': 'Type',\n            'DSID': 'DSID',\n            'COST': 'Cost',\n        }\n\n        other_cols = {\n            'PrimaryTG': 'Primary',\n            'DominantTG': 'Dominant',\n            'POINT_X': 'Longitude',\n            'POINT_Y': 'Latitude',\n        }\n\n    budget_cols = OP.format_budgets([c for c in self.matrix.columns if isinstance(c,int) and c &gt; 0])\n\n    df = pd.concat([\n        filtered[info_cols.keys()].rename(columns=info_cols),\n        self.matrix.rename(columns=budget_cols),\n        filtered[other_cols.keys()].rename(columns=other_cols),\n    ], axis=1)\n\n    dct = { t.unscaled: t.short+'_hab' for t in self.targets }\n    dct |= { f'GAIN_{t.abbrev}': t.short+'_gain' for t in self.targets }\n    df = df.rename(columns=dct)\n\n    del df[0]\n    df = df[df['count'] &gt; 0].sort_values(by='count', ascending=False).fillna('-')\n    df = df.rename(columns={'count': 'Count'})\n    df = df.reset_index(names=['ID'])\n\n    # df.columns = pd.MultiIndex.from_tuples(df.columns)\n    return df\n</code></pre>"},{"location":"developer/#optipass.TestOP","title":"<code>TestOP</code>","text":"Source code in <code>optipass.py</code> <pre><code>class TestOP:\n\n    @staticmethod\n    def test_instantiate_object():\n        '''\n        Test the OP constructor.\n        '''\n        p = Project('static/workbook.csv', DataSet.TNC_OR)\n        op = OP(p, ['Coos'], ['CO','CH'], ['1','1'], 'Current')\n        assert op.project == p\n        assert op.regions == ['Coos']\n        assert op.climate == 'Current'\n        assert op.weights == [1,1]\n        assert len(op.targets) == 2\n        t = op.targets[0]\n        assert t.abbrev == 'CO'\n        assert t.short == 'Coho'\n        assert t.long == 'Fish habitat: Coho streams'\n\n    @staticmethod\n    def test_generate_frame():\n        '''\n        Test the structure of a frame that will be printed as a\n        'barrier file' for input to OptiPass\n        '''\n\n        p = Project('static/workbook.csv', DataSet.TNC_OR)\n        op = OP(p, ['Coos'], ['CO','CH'], ['1','1'], 'Current')\n        op.generate_input_frame()\n        tf = op.input_frame\n\n        assert list(tf.columns) == ['ID','REG', 'FOCUS', 'DSID', 'HAB_CO', 'HAB_CH', 'PRE_CO', 'PRE_CH', 'NPROJ', 'ACTION', 'COST', 'POST_CO', 'POST_CH']\n\n    # NOTE:  the OPM project does not have habitat in unscaled (\"target\") units\n    # so the calls to collect_results in these tests need to specify scaled = True\n\n    @staticmethod\n    def test_example_1():\n        '''\n        Test the OPResults class by collecting results for Example 1 from the \n        OptiPass User Manual.\n        '''\n        op = OP(Project('static/test_wb.csv', DataSet.OPM), ['OPM'], ['T1'], ['1'], None)\n        op.input_frame = pd.read_csv('static/Example_1/Example1.txt', sep='\\t')\n        op.outputs = sorted(glob('static/Example_1/example_*.txt'))\n        op.collect_results(scaled=True)\n\n        assert len(op.targets) == 1\n        assert op.targets[0].abbrev == 'T1'\n        # assert len(op.weights) == 1 and round(op.weights[0]) == 1\n\n        assert type(op.summary) == pd.DataFrame\n        assert len(op.summary) == 6\n        assert round(op.summary.budget.sum()) == 1500\n        assert round(op.summary.habitat.sum(),2) == 23.30\n\n        budget_cols = [col for col in op.matrix.columns if isinstance(col,int)]\n        assert budget_cols == list(op.summary.budget)\n\n        # these comprehensions make lists of budgets where a specified gate was selected\n        assert [b for b in op.matrix.columns if b != 'count' and op.matrix.loc['A',b]] == [400,500]\n        assert [b for b in op.matrix.columns if b != 'count' and op.matrix.loc['D',b]] == [ ]\n        assert [b for b in op.matrix.columns if b != 'count' and op.matrix.loc['E',b]] == [100,300]\n\n        assert op.paths['E'] == ['E','D','A']\n        assert op.paths['A'] == ['A']\n\n    @staticmethod\n    def test_example_4():\n        '''\n        Same as test_example_1, but using Example 4, which has two restoration targets.\n        '''\n        op = OP(Project('static/test_wb.csv', DataSet.OPM), ['OPM'], ['T1','T2'], ['3','1'], None)\n        op.input_frame = pd.read_csv('static/Example_4/Example4.txt', sep='\\t')\n        op.outputs = sorted(glob('static/Example_4/example_*.txt'))\n        op.collect_results(scaled=True)\n\n        assert len(op.targets) == 2\n        assert op.targets[0].abbrev == 'T1' and op.targets[1].abbrev == 'T2'\n        assert len(op.weights) == 2 and round(sum(op.weights)) == 4\n\n        assert type(op.summary) == pd.DataFrame\n        assert len(op.summary) == 6\n        assert round(op.summary.budget.sum()) == 1500\n        assert round(op.summary.habitat.sum(),2) == 95.21\n\n        # using two targets does not change the gate selections\n        assert [b for b in op.matrix.columns if b != 'count' and op.matrix.loc['A',b]] == [400,500]\n        assert [b for b in op.matrix.columns if b != 'count' and op.matrix.loc['D',b]] == [ ]\n        assert [b for b in op.matrix.columns if b != 'count' and op.matrix.loc['E',b]] == [100,300]\n\n    @staticmethod\n    def test_potential_habitat_1():\n        '''\n        Test the method that computes potential habitat, using the results \n        genearated for Example 1 in the OptiPass manual.\n        '''\n        op = OP(Project('static/test_wb.csv', DataSet.OPM), ['OPM'], ['T1'], ['1'], None)\n        op.input_frame = pd.read_csv('static/Example_1/Example1.txt', sep='\\t')\n        op.outputs = sorted(glob('static/Example_1/example_*.txt'))\n        op.collect_results(scaled=True)\n\n        m = op.summary\n        assert len(m) == 6\n        assert 'T1' in m.columns and 'wph' in m.columns\n        assert round(m.wph[0],3) == 1.238\n        assert round(m.wph[5],3) == 8.520\n\n    @staticmethod\n    def test_potential_habitat_4():\n        '''\n        Same as test_potential_habitat_1, but using Example 4, with two restoration targets\n        '''\n        op = OP(Project('static/test_wb.csv', DataSet.OPM), ['OPM'], ['T1','T2'], ['3','1'], None)\n        op.input_frame = pd.read_csv('static/Example_4/Example4.txt', sep='\\t')\n        op.outputs = sorted(glob('static/Example_4/example_*.txt'))\n        op.collect_results(scaled=True)\n\n        m = op.summary\n        assert len(m) == 6\n        assert 'T1' in m.columns and 'T2' in m.columns and 'wph' in m.columns\n        assert round(m.wph[0],3) == 5.491\n        assert round(m.wph[4],3) == 21.084    # the value shown in the OP manual\n\n    @staticmethod\n    def test_budget_formats():\n        '''\n        Test the function that generates budget labels.\n        '''\n        assert list(OP.format_budgets([n*1000000 for n in range(1,6)]).values()) == ['$1M', '$2M', '$3M', '$4M', '$5M']\n        assert list(OP.format_budgets([n*100000 for n in range(1,6)]).values()) == ['$100K', '$200K', '$300K', '$400K', '$500K']\n        assert list(OP.format_budgets([n*500000 for n in range(1,6)]).values()) == ['$500K', '$1M', '$1.5M', '$2M', '$2.5M']\n</code></pre>"},{"location":"developer/#optipass.TestOP.test_budget_formats","title":"<code>test_budget_formats()</code>  <code>staticmethod</code>","text":"<p>Test the function that generates budget labels.</p> Source code in <code>optipass.py</code> <pre><code>@staticmethod\ndef test_budget_formats():\n    '''\n    Test the function that generates budget labels.\n    '''\n    assert list(OP.format_budgets([n*1000000 for n in range(1,6)]).values()) == ['$1M', '$2M', '$3M', '$4M', '$5M']\n    assert list(OP.format_budgets([n*100000 for n in range(1,6)]).values()) == ['$100K', '$200K', '$300K', '$400K', '$500K']\n    assert list(OP.format_budgets([n*500000 for n in range(1,6)]).values()) == ['$500K', '$1M', '$1.5M', '$2M', '$2.5M']\n</code></pre>"},{"location":"developer/#optipass.TestOP.test_example_1","title":"<code>test_example_1()</code>  <code>staticmethod</code>","text":"<p>Test the OPResults class by collecting results for Example 1 from the  OptiPass User Manual.</p> Source code in <code>optipass.py</code> <pre><code>@staticmethod\ndef test_example_1():\n    '''\n    Test the OPResults class by collecting results for Example 1 from the \n    OptiPass User Manual.\n    '''\n    op = OP(Project('static/test_wb.csv', DataSet.OPM), ['OPM'], ['T1'], ['1'], None)\n    op.input_frame = pd.read_csv('static/Example_1/Example1.txt', sep='\\t')\n    op.outputs = sorted(glob('static/Example_1/example_*.txt'))\n    op.collect_results(scaled=True)\n\n    assert len(op.targets) == 1\n    assert op.targets[0].abbrev == 'T1'\n    # assert len(op.weights) == 1 and round(op.weights[0]) == 1\n\n    assert type(op.summary) == pd.DataFrame\n    assert len(op.summary) == 6\n    assert round(op.summary.budget.sum()) == 1500\n    assert round(op.summary.habitat.sum(),2) == 23.30\n\n    budget_cols = [col for col in op.matrix.columns if isinstance(col,int)]\n    assert budget_cols == list(op.summary.budget)\n\n    # these comprehensions make lists of budgets where a specified gate was selected\n    assert [b for b in op.matrix.columns if b != 'count' and op.matrix.loc['A',b]] == [400,500]\n    assert [b for b in op.matrix.columns if b != 'count' and op.matrix.loc['D',b]] == [ ]\n    assert [b for b in op.matrix.columns if b != 'count' and op.matrix.loc['E',b]] == [100,300]\n\n    assert op.paths['E'] == ['E','D','A']\n    assert op.paths['A'] == ['A']\n</code></pre>"},{"location":"developer/#optipass.TestOP.test_example_4","title":"<code>test_example_4()</code>  <code>staticmethod</code>","text":"<p>Same as test_example_1, but using Example 4, which has two restoration targets.</p> Source code in <code>optipass.py</code> <pre><code>@staticmethod\ndef test_example_4():\n    '''\n    Same as test_example_1, but using Example 4, which has two restoration targets.\n    '''\n    op = OP(Project('static/test_wb.csv', DataSet.OPM), ['OPM'], ['T1','T2'], ['3','1'], None)\n    op.input_frame = pd.read_csv('static/Example_4/Example4.txt', sep='\\t')\n    op.outputs = sorted(glob('static/Example_4/example_*.txt'))\n    op.collect_results(scaled=True)\n\n    assert len(op.targets) == 2\n    assert op.targets[0].abbrev == 'T1' and op.targets[1].abbrev == 'T2'\n    assert len(op.weights) == 2 and round(sum(op.weights)) == 4\n\n    assert type(op.summary) == pd.DataFrame\n    assert len(op.summary) == 6\n    assert round(op.summary.budget.sum()) == 1500\n    assert round(op.summary.habitat.sum(),2) == 95.21\n\n    # using two targets does not change the gate selections\n    assert [b for b in op.matrix.columns if b != 'count' and op.matrix.loc['A',b]] == [400,500]\n    assert [b for b in op.matrix.columns if b != 'count' and op.matrix.loc['D',b]] == [ ]\n    assert [b for b in op.matrix.columns if b != 'count' and op.matrix.loc['E',b]] == [100,300]\n</code></pre>"},{"location":"developer/#optipass.TestOP.test_generate_frame","title":"<code>test_generate_frame()</code>  <code>staticmethod</code>","text":"<p>Test the structure of a frame that will be printed as a 'barrier file' for input to OptiPass</p> Source code in <code>optipass.py</code> <pre><code>@staticmethod\ndef test_generate_frame():\n    '''\n    Test the structure of a frame that will be printed as a\n    'barrier file' for input to OptiPass\n    '''\n\n    p = Project('static/workbook.csv', DataSet.TNC_OR)\n    op = OP(p, ['Coos'], ['CO','CH'], ['1','1'], 'Current')\n    op.generate_input_frame()\n    tf = op.input_frame\n\n    assert list(tf.columns) == ['ID','REG', 'FOCUS', 'DSID', 'HAB_CO', 'HAB_CH', 'PRE_CO', 'PRE_CH', 'NPROJ', 'ACTION', 'COST', 'POST_CO', 'POST_CH']\n</code></pre>"},{"location":"developer/#optipass.TestOP.test_instantiate_object","title":"<code>test_instantiate_object()</code>  <code>staticmethod</code>","text":"<p>Test the OP constructor.</p> Source code in <code>optipass.py</code> <pre><code>@staticmethod\ndef test_instantiate_object():\n    '''\n    Test the OP constructor.\n    '''\n    p = Project('static/workbook.csv', DataSet.TNC_OR)\n    op = OP(p, ['Coos'], ['CO','CH'], ['1','1'], 'Current')\n    assert op.project == p\n    assert op.regions == ['Coos']\n    assert op.climate == 'Current'\n    assert op.weights == [1,1]\n    assert len(op.targets) == 2\n    t = op.targets[0]\n    assert t.abbrev == 'CO'\n    assert t.short == 'Coho'\n    assert t.long == 'Fish habitat: Coho streams'\n</code></pre>"},{"location":"developer/#optipass.TestOP.test_potential_habitat_1","title":"<code>test_potential_habitat_1()</code>  <code>staticmethod</code>","text":"<p>Test the method that computes potential habitat, using the results  genearated for Example 1 in the OptiPass manual.</p> Source code in <code>optipass.py</code> <pre><code>@staticmethod\ndef test_potential_habitat_1():\n    '''\n    Test the method that computes potential habitat, using the results \n    genearated for Example 1 in the OptiPass manual.\n    '''\n    op = OP(Project('static/test_wb.csv', DataSet.OPM), ['OPM'], ['T1'], ['1'], None)\n    op.input_frame = pd.read_csv('static/Example_1/Example1.txt', sep='\\t')\n    op.outputs = sorted(glob('static/Example_1/example_*.txt'))\n    op.collect_results(scaled=True)\n\n    m = op.summary\n    assert len(m) == 6\n    assert 'T1' in m.columns and 'wph' in m.columns\n    assert round(m.wph[0],3) == 1.238\n    assert round(m.wph[5],3) == 8.520\n</code></pre>"},{"location":"developer/#optipass.TestOP.test_potential_habitat_4","title":"<code>test_potential_habitat_4()</code>  <code>staticmethod</code>","text":"<p>Same as test_potential_habitat_1, but using Example 4, with two restoration targets</p> Source code in <code>optipass.py</code> <pre><code>@staticmethod\ndef test_potential_habitat_4():\n    '''\n    Same as test_potential_habitat_1, but using Example 4, with two restoration targets\n    '''\n    op = OP(Project('static/test_wb.csv', DataSet.OPM), ['OPM'], ['T1','T2'], ['3','1'], None)\n    op.input_frame = pd.read_csv('static/Example_4/Example4.txt', sep='\\t')\n    op.outputs = sorted(glob('static/Example_4/example_*.txt'))\n    op.collect_results(scaled=True)\n\n    m = op.summary\n    assert len(m) == 6\n    assert 'T1' in m.columns and 'T2' in m.columns and 'wph' in m.columns\n    assert round(m.wph[0],3) == 5.491\n    assert round(m.wph[4],3) == 21.084    # the value shown in the OP manual\n</code></pre>"},{"location":"install/","title":"Installation","text":"<p>How to install</p>"},{"location":"server/","title":"Running the Server","text":""},{"location":"server/#local","title":"Local","text":""},{"location":"server/#remote","title":"Remote","text":""},{"location":"user/","title":"How to Use the Optimzation Tool","text":"<p>Using the tool</p>"}]}